--- src/input/libdvdread/dvd_input.c	2003-02-13 22:48:24.000000000 +0100
+++ src/input/libdvdread/dvd_input.c	2003-02-28 14:12:36.000000000 +0100
@@ -74,7 +74,7 @@
   dvd_input_t dev;
     
   /* Allocate the handle structure */
-  dev = (dvd_input_t) malloc(sizeof(dvd_input_t));
+  dev = (dvd_input_t) malloc(sizeof(*dev));
   if(dev == NULL) {
     fprintf(stderr, "libdvdread: Could not allocate memory.\n");
     return NULL;
@@ -154,7 +154,7 @@
   dvd_input_t dev;
   
   /* Allocate the library structure */
-  dev = (dvd_input_t) malloc(sizeof(dvd_input_t));
+  dev = (dvd_input_t) malloc(sizeof(*dev));
   if(dev == NULL) {
     fprintf(stderr, "libdvdread: Could not allocate memory.\n");
     return NULL;
--- src/input/libdvdread/dvd_reader.c	2003-02-13 23:31:21.000000000 +0100
+++ src/input/libdvdread/dvd_reader.c	2003-02-28 14:24:48.000000000 +0100
@@ -44,6 +44,7 @@
 #include <mntent.h>
 #endif
 
+#include "compat.h"
 #include "dvd_udf.h"
 #include "dvd_input.h"
 #include "dvd_reader.h"
@@ -349,7 +350,7 @@
 	    
 	    if( cdir >= 0 ) {
 		chdir( path_copy );
-		new_path = getcwd( NULL, PATH_MAX );
+		new_path = getcwd( NULL, XINE_PATH_MAX );
 		fchdir( cdir );
 		close( cdir );
 		if( new_path ) {
@@ -513,7 +514,7 @@
 
 static int findDVDFile( dvd_reader_t *dvd, const char *file, char *filename )
 {
-    char video_path[ PATH_MAX + 1 ];
+    char video_path[ XINE_PATH_MAX + 1 ];
     const char *nodirfile;
     int ret;
 
@@ -547,7 +548,7 @@
  */
 static dvd_file_t *DVDOpenFilePath( dvd_reader_t *dvd, char *filename )
 {
-    char full_path[ PATH_MAX + 1 ];
+    char full_path[ XINE_PATH_MAX + 1 ];
     dvd_file_t *dvd_file;
     struct stat fileinfo;
     dvd_input_t dev;
@@ -631,7 +632,7 @@
 static dvd_file_t *DVDOpenVOBPath( dvd_reader_t *dvd, int title, int menu )
 {
     char filename[ MAX_UDF_FILE_NAME_LEN ];
-    char full_path[ PATH_MAX + 1 ];
+    char full_path[ XINE_PATH_MAX + 1 ];
     struct stat fileinfo;
     dvd_file_t *dvd_file;
     int i;
@@ -930,7 +931,7 @@
 
 ssize_t DVDReadBytes( dvd_file_t *dvd_file, void *data, size_t byte_size )
 {
-    unsigned char *secbuf;
+    unsigned char *secbuf_base, *secbuf;
     unsigned int numsec, seek_sector, seek_byte;
     int ret;
     
@@ -944,8 +945,9 @@
     numsec = ( ( seek_byte + byte_size ) / DVD_VIDEO_LB_LEN ) +
       ( ( ( seek_byte + byte_size ) % DVD_VIDEO_LB_LEN ) ? 1 : 0 );
     
-    secbuf = (unsigned char *) malloc( numsec * DVD_VIDEO_LB_LEN );
-    if( !secbuf ) {
+    secbuf_base = (unsigned char *) malloc( numsec * DVD_VIDEO_LB_LEN + 2048 );
+    secbuf = (unsigned char *)(((int)secbuf_base & ~2047) + 2048);
+    if( !secbuf_base ) {
 	fprintf( stderr, "libdvdread: Can't allocate memory " 
 		 "for file read!\n" );
         return 0;
@@ -960,12 +962,12 @@
     }
 
     if( ret != (int) numsec ) {
-        free( secbuf );
+        free( secbuf_base );
         return ret < 0 ? ret : 0;
     }
 
     memcpy( data, &(secbuf[ seek_byte ]), byte_size );
-    free( secbuf );
+    free( secbuf_base );
 
     dvd_file->seek_pos += byte_size;
     return byte_size;
@@ -997,9 +999,10 @@
 	if( dvd_file != NULL ) {
 	    ssize_t bytes_read;
 	    size_t file_size = dvd_file->filesize * DVD_VIDEO_LB_LEN;
-	    char *buffer = malloc( file_size );
+	    char *buffer_base = malloc( file_size + 2048 );
+	    char *buffer = (unsigned char *)(((int)buffer_base & ~2047) + 2048);
 	    
-	    if( buffer == NULL ) {
+	    if( buffer_base == NULL ) {
 		fprintf( stderr, "libdvdread: DVDDiscId, failed to "
 			 "allocate memory for file read!\n" );
 		return -1;
@@ -1009,13 +1012,14 @@
 		fprintf( stderr, "libdvdread: DVDDiscId read returned %d bytes"
 			 ", wanted %d\n", bytes_read, file_size );
 		DVDCloseFile( dvd_file );
+		free( buffer_base );
 		return -1;
 	    }
 	    
 	    md5_process_bytes( buffer, file_size,  &ctx );
 	    
 	    DVDCloseFile( dvd_file );
-	    free( buffer );
+	    free( buffer_base );
 	}
     }
     md5_finish_ctx( &ctx, discid );
@@ -1028,7 +1032,7 @@
 		      char *volid, unsigned int volid_size,
 		      unsigned char *volsetid, unsigned int volsetid_size )
 {
-  unsigned char *buffer;
+  unsigned char *buffer, *buffer_base;
   int ret;
 
   /* Check arguments. */
@@ -1040,8 +1044,10 @@
     return -1;
   }
   
-  buffer = malloc( DVD_VIDEO_LB_LEN );
-  if( buffer == NULL ) {
+  buffer_base = malloc( DVD_VIDEO_LB_LEN + 2048 );
+  buffer = (unsigned char *)(((int)buffer_base & ~2047) + 2048);
+
+  if( buffer_base == NULL ) {
     fprintf( stderr, "libdvdread: DVDISOVolumeInfo, failed to "
 	     "allocate memory for file read!\n" );
     return -1;
@@ -1051,6 +1057,7 @@
   if( ret != 1 ) {
     fprintf( stderr, "libdvdread: DVDISOVolumeInfo, failed to "
 	     "read ISO9660 Primary Volume Descriptor!\n" );
+    free( buffer_base );
     return -1;
   }
   
@@ -1076,6 +1083,7 @@
     }
     memcpy(volsetid, &buffer[190], volsetid_size);
   }
+  free( buffer_base );
   return 0;
 }
 
--- src/input/libdvdread/dvd_udf.c	2003-02-13 22:57:17.000000000 +0100
+++ src/input/libdvdread/dvd_udf.c	2003-02-28 14:53:36.000000000 +0100
@@ -237,7 +237,7 @@
   
   if(c == NULL) {
     c = calloc(1, sizeof(struct udf_cache));    
-    //    fprintf(stderr, "calloc: %d\n", sizeof(struct udf_cache));    
+    /* fprintf(stderr, "calloc: %d\n", sizeof(struct udf_cache)); */
     if(c == NULL) {
       return 0;
     }
@@ -346,7 +346,7 @@
 static int UDFDescriptor( uint8_t *data, uint16_t *TagID ) 
 {
     *TagID = GETN2(0);
-    // TODO: check CRC 'n stuff
+    /* TODO: check CRC 'n stuff */
     return 0;
 }
 
@@ -364,7 +364,7 @@
     ad->Flags = ad->Length >> 30;
     ad->Length &= 0x3FFFFFFF;
     ad->Location = GETN4(4);
-    ad->Partition = partition->Number; // use number of current partition
+    ad->Partition = partition->Number; /* use number of current partition */
     return 0;
 }
 
@@ -375,7 +375,7 @@
     ad->Length &= 0x3FFFFFFF;
     ad->Location = GETN4(4);
     ad->Partition = GETN2(8);
-    //GETN(10, 6, Use);
+    /* GETN(10, 6, Use); */
     return 0;
 }
 
@@ -386,7 +386,7 @@
     ad->Length &= 0x3FFFFFFF;
     ad->Location = GETN4(12);
     ad->Partition = GETN2(16);
-    //GETN(10, 6, Use);
+    /* GETN(10, 6, Use); */
     return 0;
 }
 
@@ -417,9 +417,9 @@
 {
     uint32_t lbsize, MT_L, N_PM;
     Unicodedecode(&data[84], 128, VolumeDescriptor);
-    lbsize = GETN4(212);  // should be 2048
-    MT_L = GETN4(264);    // should be 6
-    N_PM = GETN4(268);    // should be 1
+    lbsize = GETN4(212);  /* should be 2048 */
+    MT_L = GETN4(264);    /* should be 6 */
+    N_PM = GETN4(268);    /* should be 1 */
     if (lbsize != DVD_VIDEO_LB_LEN) return 1;
     return 0;
 }
@@ -434,10 +434,10 @@
     UDFICB( &data[ 16 ], FileType, &flags );
    
     /* Init ad for an empty file (i.e. there isn't a AD, L_AD == 0 ) */
-    ad->Length = GETN4( 60 ); // Really 8 bytes a 56
+    ad->Length = GETN4( 60 ); /* Really 8 bytes a 56 */
     ad->Flags = 0;
-    ad->Location = 0; // what should we put here? 
-    ad->Partition = partition->Number; // use number of current partition
+    ad->Location = 0; /* what should we put here?  */
+    ad->Partition = partition->Number; /* use number of current partition */
 
     L_EA = GETN4( 168 );
     L_AD = GETN4( 172 );
@@ -487,7 +487,8 @@
 static int UDFMapICB( dvd_reader_t *device, struct AD ICB, uint8_t *FileType,
 		      struct Partition *partition, struct AD *File ) 
 {
-    uint8_t LogBlock[DVD_VIDEO_LB_LEN];
+    uint8_t LogBlock_base[DVD_VIDEO_LB_LEN + 2048];
+    uint8_t *LogBlock = (uint8_t *)(((int)LogBlock_base & ~2047) + 2048);
     uint32_t lbnum;
     uint16_t TagID;
     struct icbmap tmpmap;
@@ -531,12 +532,13 @@
 		       int cache_file_info) 
 {
     char filename[ MAX_UDF_FILE_NAME_LEN ];
-    uint8_t directory[ 2 * DVD_VIDEO_LB_LEN ];
+    uint8_t directory_base[ 2 * DVD_VIDEO_LB_LEN + 2048];
+    uint8_t *directory = (uint8_t *)(((int)directory_base & ~2047) + 2048);
     uint32_t lbnum;
     uint16_t TagID;
     uint8_t filechar;
     unsigned int p;
-    uint8_t *cached_dir = NULL;
+    uint8_t *cached_dir_base = NULL, *cached_dir;
     uint32_t dir_lba;
     struct AD tmpICB;
     int found = 0;
@@ -550,11 +552,12 @@
       
       if(!GetUDFCache(device, LBUDFCache, lbnum, &cached_dir)) {
 	dir_lba = (Dir.Length + DVD_VIDEO_LB_LEN) / DVD_VIDEO_LB_LEN;
-	if((cached_dir = malloc(dir_lba * DVD_VIDEO_LB_LEN)) == NULL) {
+	if((cached_dir_base = malloc(dir_lba * DVD_VIDEO_LB_LEN + 2048)) == NULL) {
 	  return 0;
 	}
+	cached_dir = (uint8_t *)(((int)cached_dir_base & ~2047) + 2048);
 	if( DVDReadLBUDF( device, lbnum, dir_lba, cached_dir, 0) <= 0 ) {
-	  free(cached_dir);
+	  free(cached_dir_base);
 	  cached_dir = NULL;
 	}
 	/*
@@ -642,7 +645,8 @@
 static int UDFGetAVDP( dvd_reader_t *device,
 		       struct avdp_t *avdp)
 {
-  uint8_t Anchor[ DVD_VIDEO_LB_LEN ];
+  uint8_t Anchor_base[ DVD_VIDEO_LB_LEN + 2048 ];
+  uint8_t *Anchor = (uint8_t *)(((int)Anchor_base & ~2047) + 2048);
   uint32_t lbnum, MVDS_location, MVDS_length;
   uint16_t TagID;
   uint32_t lastsector;
@@ -713,7 +717,8 @@
 static int UDFFindPartition( dvd_reader_t *device, int partnum,
 			     struct Partition *part ) 
 {
-    uint8_t LogBlock[ DVD_VIDEO_LB_LEN ];
+    uint8_t LogBlock_base[ DVD_VIDEO_LB_LEN + 2048 ];
+    uint8_t *LogBlock = (uint8_t *)(((int)LogBlock_base & ~2047) + 2048);
     uint32_t lbnum, MVDS_location, MVDS_length;
     uint16_t TagID;
     int i, volvalid;
@@ -775,7 +780,8 @@
 uint32_t UDFFindFile( dvd_reader_t *device, char *filename,
 		      uint32_t *filesize )
 {
-    uint8_t LogBlock[ DVD_VIDEO_LB_LEN ];
+    uint8_t LogBlock_base[ DVD_VIDEO_LB_LEN + 2048 ];
+    uint8_t *LogBlock = (uint8_t *)(((int)LogBlock_base & ~2047) + 2048);
     uint32_t lbnum;
     uint16_t TagID;
     struct Partition partition;
@@ -805,7 +811,7 @@
         }
 
         /* File Set Descriptor */
-        if( TagID == 256 ) {  // File Set Descriptor
+        if( TagID == 256 ) {  /* File Set Descriptor */
             UDFLongAD( &LogBlock[ 400 ], &RootICB );
         }
     } while( ( lbnum < partition.Start + partition.Length )
@@ -919,7 +925,8 @@
 
 static int UDFGetPVD(dvd_reader_t *device, struct pvd_t *pvd)
 {
-  uint8_t pvd_buf[DVD_VIDEO_LB_LEN];
+  uint8_t pvd_buf_base[DVD_VIDEO_LB_LEN + 2048];
+  uint8_t *pvd_buf = (uint8_t *)(((int)pvd_buf_base & ~2047) + 2048);
   
   if(GetUDFCache(device, PVDCache, 0, pvd)) {
     return 1;
--- src/input/libdvdread/ifo_print.c	2003-02-02 03:23:53.000000000 +0100
+++ src/input/libdvdread/ifo_print.c	2003-02-28 14:40:32.000000000 +0100
@@ -73,7 +73,7 @@
     printf("%02x ", command->bytes[i]);
   printf("| ");
 
-  //vmcmd(command);
+  /* vmcmd(command); */
   printf("\n");
 }
 
@@ -129,19 +129,19 @@
     printf("(please send a bug report) ");
   }
   
-  // Wide is allways allowed..!!!
+  /*  Wide is allways allowed..!!! */
   switch(attr->permitted_df) {
   case 0:
     printf("pan&scan+letterboxed ");
     break;
   case 1:
-    printf("only pan&scan "); //??
+    printf("only pan&scan "); /* ?? */
     break;
   case 2:
     printf("only letterboxed ");
     break;
   case 3:
-    // not specified
+    /* not specified */
     break;
   default:
     printf("(please send a bug report)");
@@ -198,7 +198,7 @@
   if(attr->film_mode) {
     printf("film");
   } else {
-    printf("video"); //camera
+    printf("video"); /* camera */
   }
 }
 
@@ -251,7 +251,7 @@
   
   switch(attr->lang_type) {
   case 0:
-    // not specified
+    /* not specified */
     CHECK_VALUE(attr->lang_code == 0 || attr->lang_code == 0xffff);
     break;
   case 1:
@@ -264,7 +264,7 @@
 
   switch(attr->application_mode) {
   case 0:
-    // not specified
+    /* not specified */
     break;
   case 1:
     printf("karaoke mode ");
@@ -311,19 +311,19 @@
   case 0:
     printf("Not specified ");
     break;
-  case 1: // Normal audio
+  case 1: /* Normal audio */
     printf("Normal Caption ");
     break;
-  case 2: // visually imparied
+  case 2: /* visually imparied */
     printf("Audio for visually impaired ");
     break;
-  case 3: // Directors 1
+  case 3: /* Directors 1 */
     printf("Director's comments 1 ");
     break;
-  case 4: // Directors 2
+  case 4: /* Directors 2 */
     printf("Director's comments 2 ");
     break;
-    //case 4: // Music score ?    
+    /* case 4: Music score ? */
   default:
     printf("(please send a bug report) ");
   }
@@ -913,7 +913,7 @@
   int i, entries;
   
   printf("Number of VOBs in this VOBS: %i\n", c_adt->nr_of_vobs);
-  //entries = c_adt->nr_of_vobs;
+  /* entries = c_adt->nr_of_vobs; */
   entries = (c_adt->last_byte + 1 - C_ADT_SIZE)/sizeof(c_adt_t);
   
   for(i = 0; i < entries; i++) {
@@ -1066,7 +1066,7 @@
     printf("\nText Data Manager Information\n");
     printf(  "-----------------------------\n");
     if(ifohandle->txtdt_mgi) {
-      //ifoPrint_TXTDT_MGI(&(vmgi->txtdt_mgi));
+      /* ifoPrint_TXTDT_MGI(&(vmgi->txtdt_mgi)); */
     } else {
       printf("No Text Data Manager Information present\n");
     }
--- src/input/libdvdread/ifo_print.h	2002-08-15 22:13:21.000000000 +0200
+++ src/input/libdvdread/ifo_print.h	2003-02-28 14:12:36.000000000 +0100
@@ -20,8 +20,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include <dvdread/ifo_types.h>
-#include <dvdread/dvd_reader.h>
+#include "ifo_types.h"
+#include "dvd_reader.h"
 
 #ifdef __cplusplus
 extern "C" {
--- src/input/libdvdread/ifo_read.c	2003-01-17 21:49:16.000000000 +0100
+++ src/input/libdvdread/ifo_read.c	2003-02-28 14:43:40.000000000 +0100
@@ -659,7 +659,7 @@
   /* Check that time is 0:0:0:0 also if nr_of_programs == 0 */
   if(pgc->nr_of_programs == 0) {
     CHECK_ZERO(pgc->still_time);
-    CHECK_ZERO(pgc->pg_playback_mode); // ??
+    CHECK_ZERO(pgc->pg_playback_mode); /* ?? */
     CHECK_VALUE(pgc->program_map_offset == 0);
     CHECK_VALUE(pgc->cell_playback_offset == 0);
     CHECK_VALUE(pgc->cell_position_offset == 0);
@@ -844,24 +844,24 @@
 
   CHECK_ZERO(tt_srpt->zero_1);
   CHECK_VALUE(tt_srpt->nr_of_srpts != 0);
-  CHECK_VALUE(tt_srpt->nr_of_srpts < 100); // ??
+  CHECK_VALUE(tt_srpt->nr_of_srpts < 100); /* ?? */
   CHECK_VALUE((int)tt_srpt->nr_of_srpts * sizeof(title_info_t) <= info_length);
   
   for(i = 0; i < tt_srpt->nr_of_srpts; i++) {
     CHECK_VALUE(tt_srpt->title[i].pb_ty.zero_1 == 0);
     CHECK_VALUE(tt_srpt->title[i].nr_of_angles != 0);
     CHECK_VALUE(tt_srpt->title[i].nr_of_angles < 10);
-    //CHECK_VALUE(tt_srpt->title[i].nr_of_ptts != 0);
-    // XXX: this assertion breaks Ghostbusters:
-    CHECK_VALUE(tt_srpt->title[i].nr_of_ptts < 1000); // ??
+    /* CHECK_VALUE(tt_srpt->title[i].nr_of_ptts != 0); */
+    /* XXX: this assertion breaks Ghostbusters: */
+    CHECK_VALUE(tt_srpt->title[i].nr_of_ptts < 1000); /* ?? */
     CHECK_VALUE(tt_srpt->title[i].title_set_nr != 0);
-    CHECK_VALUE(tt_srpt->title[i].title_set_nr < 100); // ??
+    CHECK_VALUE(tt_srpt->title[i].title_set_nr < 100); /* ?? */
     CHECK_VALUE(tt_srpt->title[i].vts_ttn != 0);
-    CHECK_VALUE(tt_srpt->title[i].vts_ttn < 100); // ??
-    //CHECK_VALUE(tt_srpt->title[i].title_set_sector != 0);
+    CHECK_VALUE(tt_srpt->title[i].vts_ttn < 100); /* ?? */
+    /* CHECK_VALUE(tt_srpt->title[i].title_set_sector != 0); */
   }
   
-  // Make this a function
+  /* Make this a function */
 #if 0
   if(memcmp((uint8_t *)tt_srpt->title + 
             tt_srpt->nr_of_srpts * sizeof(title_info_t), 
@@ -925,7 +925,7 @@
 
   CHECK_ZERO(vts_ptt_srpt->zero_1);
   CHECK_VALUE(vts_ptt_srpt->nr_of_srpts != 0);
-  CHECK_VALUE(vts_ptt_srpt->nr_of_srpts < 100); // ??
+  CHECK_VALUE(vts_ptt_srpt->nr_of_srpts < 100); /* ?? */
   
   info_length = vts_ptt_srpt->last_byte + 1 - VTS_PTT_SRPT_SIZE;
   
@@ -1001,12 +1001,12 @@
   }
   
   for(i = 0; i < vts_ptt_srpt->nr_of_srpts; i++) {
-    CHECK_VALUE(vts_ptt_srpt->title[i].nr_of_ptts < 1000); // ??
+    CHECK_VALUE(vts_ptt_srpt->title[i].nr_of_ptts < 1000); /* ?? */
     for(j = 0; j < vts_ptt_srpt->title[i].nr_of_ptts; j++) {
       CHECK_VALUE(vts_ptt_srpt->title[i].ptt[j].pgcn != 0 );
-      CHECK_VALUE(vts_ptt_srpt->title[i].ptt[j].pgcn < 1000); // ??
+      CHECK_VALUE(vts_ptt_srpt->title[i].ptt[j].pgcn < 1000); /* ?? */
       CHECK_VALUE(vts_ptt_srpt->title[i].ptt[j].pgn != 0);
-      CHECK_VALUE(vts_ptt_srpt->title[i].ptt[j].pgn < 100); // ??
+      CHECK_VALUE(vts_ptt_srpt->title[i].ptt[j].pgn < 100); /* ?? */
     }
   }
 
@@ -1064,9 +1064,9 @@
   B2N_32(ptl_mait->last_byte);
   
   CHECK_VALUE(ptl_mait->nr_of_countries != 0);
-  CHECK_VALUE(ptl_mait->nr_of_countries < 100); // ??
+  CHECK_VALUE(ptl_mait->nr_of_countries < 100); /* ?? */
   CHECK_VALUE(ptl_mait->nr_of_vtss != 0);
-  CHECK_VALUE(ptl_mait->nr_of_vtss < 100); // ??  
+  CHECK_VALUE(ptl_mait->nr_of_vtss < 100); /* ?? */
   CHECK_VALUE(ptl_mait->nr_of_countries * PTL_MAIT_COUNTRY_SIZE 
 	      <= ptl_mait->last_byte + 1 - PTL_MAIT_SIZE);
   
@@ -1605,7 +1605,7 @@
   /* assert(pgcit->nr_of_pgci_srp != 0);
      Magic Knight Rayearth Daybreak is mastered very strange and has 
      Titles with 0 PTTs. */
-  CHECK_VALUE(pgcit->nr_of_pgci_srp < 10000); // ?? seen max of 1338
+  CHECK_VALUE(pgcit->nr_of_pgci_srp < 10000); /* ?? seen max of 1338 */
   
   info_length = pgcit->nr_of_pgci_srp * PGCI_SRP_SIZE;
   data = malloc(info_length);
@@ -1726,7 +1726,7 @@
   
   CHECK_ZERO(pgci_ut->zero_1);
   CHECK_VALUE(pgci_ut->nr_of_lus != 0);
-  CHECK_VALUE(pgci_ut->nr_of_lus < 100); // ?? 3-4 ?
+  CHECK_VALUE(pgci_ut->nr_of_lus < 100); /* ?? 3-4 ? */
   CHECK_VALUE((uint32_t)pgci_ut->nr_of_lus * PGCI_LU_SIZE < pgci_ut->last_byte);
 
   info_length = pgci_ut->nr_of_lus * PGCI_LU_SIZE;
@@ -1760,7 +1760,7 @@
   free(data);
   
   for(i = 0; i < pgci_ut->nr_of_lus; i++) {
-    // Maybe this is only defined for v1.1 and later titles?
+    /* Maybe this is only defined for v1.1 and later titles? */
     /* If the bits in 'lu[i].exists' are enumerated abcd efgh then:
             VTS_x_yy.IFO        VIDEO_TS.IFO
        a == 0x83 "Root"         0x82 "Title"
@@ -1799,8 +1799,10 @@
       ifofile->pgci_ut = 0;
       return 0;
     }
-    // FIXME: Iterate and verify that all menus that should exists accordingly
-    //        to pgci_ut->lu[i].exists really do?
+    /*
+		 * FIXME: Iterate and verify that all menus that should exists accordingly
+		 * to pgci_ut->lu[i].exists really do?
+		 */
   }
 
   return 1;
@@ -1861,8 +1863,8 @@
     unsigned int nr_coded;
     CHECK_VALUE(vts_attributes->last_byte + 1 >= VTS_ATTRIBUTES_MIN_SIZE);  
     nr_coded = (vts_attributes->last_byte + 1 - VTS_ATTRIBUTES_MIN_SIZE)/6;
-    // This is often nr_coded = 70, how do you know how many there really are?
-    if(nr_coded > 32) { // We haven't read more from disk/file anyway
+    /* This is often nr_coded = 70, how do you know how many there really are? */
+    if(nr_coded > 32) { /* We haven't read more from disk/file anyway */
       nr_coded = 32;
     }
     CHECK_VALUE(vts_attributes->nr_of_vtstt_subp_streams <= nr_coded);
@@ -1910,7 +1912,7 @@
 
   CHECK_ZERO(vts_atrt->zero_1);
   CHECK_VALUE(vts_atrt->nr_of_vtss != 0);
-  CHECK_VALUE(vts_atrt->nr_of_vtss < 100); //??
+  CHECK_VALUE(vts_atrt->nr_of_vtss < 100); /* ?? */
   CHECK_VALUE((uint32_t)vts_atrt->nr_of_vtss * (4 + VTS_ATTRIBUTES_MIN_SIZE) + 
          VTS_ATRT_SIZE < vts_atrt->last_byte + 1);
 
@@ -1954,9 +1956,9 @@
       return 0;
     }
 
-    // This assert cant be in ifoRead_VTS_ATTRIBUTES
+    /* This assert cant be in ifoRead_VTS_ATTRIBUTES */
     CHECK_VALUE(offset + vts_atrt->vts[i].last_byte <= vts_atrt->last_byte + 1);
-    // Is this check correct?
+    /* Is this check correct? */
   }
 
   return 1;
@@ -2006,7 +2008,7 @@
     return 0;
   }
 
-  // fprintf(stderr, "-- Not done yet --\n");
+  /* fprintf(stderr, "-- Not done yet --\n"); */
   return 1;
 }
 
--- src/input/libdvdread/ifo_read.h	2002-12-15 01:09:12.000000000 +0100
+++ src/input/libdvdread/ifo_read.h	2003-02-28 14:12:36.000000000 +0100
@@ -20,8 +20,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include <dvdread/ifo_types.h>
-#include <dvdread/dvd_reader.h>
+#include "ifo_types.h"
+#include "dvd_reader.h"
 
 #ifdef __cplusplus
 extern "C" {
--- src/input/libdvdread/ifo_types.h	2003-02-22 22:42:11.000000000 +0100
+++ src/input/libdvdread/ifo_types.h	2003-02-28 14:12:36.000000000 +0100
@@ -21,7 +21,7 @@
  */
 
 #include <inttypes.h>
-#include <dvdread/dvd_reader.h>
+#include "dvd_reader.h"
 
 
 #undef ATTRIBUTE_PACKED
--- src/input/libdvdread/md5.c	2003-01-12 01:46:16.000000000 +0100
+++ src/input/libdvdread/md5.c	2003-02-28 14:53:15.000000000 +0100
@@ -36,7 +36,7 @@
 #endif
 
 #include "md5.h"
-//#include "unlocked-io.h"
+/* #include "unlocked-io.h" */
 
 #ifdef _LIBC
 # include <endian.h>
--- src/input/libdvdread/nav_print.c	2003-01-07 21:58:15.000000000 +0100
+++ src/input/libdvdread/nav_print.c	2003-02-28 14:12:36.000000000 +0100
@@ -167,7 +167,7 @@
 	printf("left %d, ", btni->left);
 	printf("right %d\n", btni->right);
 	
-	// ifoPrint_COMMAND(&btni->cmd);
+	/* ifoPrint_COMMAND(&btni->cmd); */
 	printf("\n");
       }
     }
--- src/input/libdvdread/nav_print.h	2002-07-26 23:20:28.000000000 +0200
+++ src/input/libdvdread/nav_print.h	2003-02-28 14:12:36.000000000 +0100
@@ -20,7 +20,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include <dvdread/nav_types.h>
+#include "nav_types.h"
 
 /**
  * Pretty printing of the NAV packets, PCI and DSI structs.
--- src/input/libdvdread/nav_read.c	2003-01-07 21:58:15.000000000 +0100
+++ src/input/libdvdread/nav_read.c	2003-02-28 14:49:04.000000000 +0100
@@ -30,7 +30,7 @@
 void navRead_PCI(pci_t *pci, unsigned char *buffer) {
   int i, j;
 
-  CHECK_VALUE(sizeof(pci_t) == PCI_BYTES - 1); // -1 for substream id
+  CHECK_VALUE(sizeof(pci_t) == PCI_BYTES - 1); /* -1 for substream id */
   
   memcpy(pci, buffer, sizeof(pci_t));
 
@@ -126,7 +126,7 @@
 	CHECK_VALUE(pci->hli.btnit[n].down <= pci->hli.hl_gi.btn_ns);
 	CHECK_VALUE(pci->hli.btnit[n].left <= pci->hli.hl_gi.btn_ns);
 	CHECK_VALUE(pci->hli.btnit[n].right <= pci->hli.hl_gi.btn_ns);
-	//vmcmd_verify(pci->hli.btnit[n].cmd);
+	/*vmcmd_verify(pci->hli.btnit[n].cmd);*/
       } else {
 	int k;
 	CHECK_VALUE(pci->hli.btnit[n].btn_coln == 0);
@@ -140,7 +140,7 @@
 	CHECK_VALUE(pci->hli.btnit[n].left == 0);
 	CHECK_VALUE(pci->hli.btnit[n].right == 0);
 	for (k = 0; k < 8; k++)
-	  CHECK_VALUE(pci->hli.btnit[n].cmd.bytes[k] == 0); //CHECK_ZERO?
+	  CHECK_VALUE(pci->hli.btnit[n].cmd.bytes[k] == 0); /* CHECK_ZERO? */
       }
     }
   }
@@ -150,7 +150,7 @@
 void navRead_DSI(dsi_t *dsi, unsigned char *buffer) {
   int i;
 
-  CHECK_VALUE(sizeof(dsi_t) == DSI_BYTES - 1); // -1 for substream id
+  CHECK_VALUE(sizeof(dsi_t) == DSI_BYTES - 1); /* -1 for substream id */
   
   memcpy(dsi, buffer, sizeof(dsi_t));
 
--- src/input/libdvdread/nav_read.h	2002-07-26 23:04:05.000000000 +0200
+++ src/input/libdvdread/nav_read.h	2003-02-28 14:12:36.000000000 +0100
@@ -19,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include <dvdread/nav_types.h>
+#include "nav_types.h"
 
 /**
  * Parsing of NAV data, PCI and DSI parts.
--- src/input/libdvdread/nav_types.h	2003-01-02 21:11:06.000000000 +0100
+++ src/input/libdvdread/nav_types.h	2003-02-28 14:12:36.000000000 +0100
@@ -30,7 +30,7 @@
  */
 
 #include <inttypes.h>
-#include <dvdread/ifo_types.h> /* only dvd_time_t, vm_cmd_t and user_ops_t */
+#include "ifo_types.h" /* only dvd_time_t, vm_cmd_t and user_ops_t */
 
 
 #undef ATTRIBUTE_PACKED
