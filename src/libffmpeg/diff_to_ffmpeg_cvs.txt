? ffmpeg-030211.patch
Index: libavcodec/common.h
===================================================================
RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/common.h,v
retrieving revision 1.87
diff -u -r1.87 common.h
--- libavcodec/common.h	26 Mar 2003 10:39:34 -0000	1.87
+++ libavcodec/common.h	26 Mar 2003 13:49:18 -0000
@@ -178,11 +178,19 @@
 
 #    else
 
-#        ifdef DEBUG
-#            define dprintf(fmt,args...) printf(fmt, ## args)
-#        else
-#            define dprintf(fmt,args...)
-#        endif
+#if __GNUC__
+#ifdef DEBUG
+#define dprintf(fmt,args...) printf(fmt, ## args)
+#else
+#define dprintf(fmt,args...)
+#endif
+#else
+#ifdef DEBUG
+#define dprintf(...) printf(__VA_ARGS__)
+#else
+#define dprintf(...)
+#endif
+#endif
 
 #    endif /* !CONFIG_WIN32 */
 
Index: libavcodec/dsputil.h
===================================================================
RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/dsputil.h,v
retrieving revision 1.60
diff -u -r1.60 dsputil.h
--- libavcodec/dsputil.h	15 Mar 2003 02:06:09 -0000	1.60
+++ libavcodec/dsputil.h	26 Mar 2003 13:49:18 -0000
@@ -29,9 +29,14 @@
 
 #include "common.h"
 #include "avcodec.h"
+#include "xineutils.h"
 
+#if defined(ARCH_X86)
+#define HAVE_MMX 1 
+#endif
+
+#undef DEBUG
 
-//#define DEBUG
 /* dct code */
 typedef short DCTELEM;
 //typedef int DCTELEM;
@@ -310,21 +315,25 @@
 
 #undef emms_c
 
+#if 0
 #define MM_MMX    0x0001 /* standard MMX */
 #define MM_3DNOW  0x0004 /* AMD 3DNOW */
 #define MM_MMXEXT 0x0002 /* SSE integer functions or AMD MMX ext */
 #define MM_SSE    0x0008 /* SSE functions */
 #define MM_SSE2   0x0010 /* PIV SSE2 functions */
+#endif
 
 extern int mm_flags;
 
 void add_pixels_clamped_mmx(const DCTELEM *block, uint8_t *pixels, int line_size);
 void put_pixels_clamped_mmx(const DCTELEM *block, uint8_t *pixels, int line_size);
 
+#if 0 
 static inline void emms(void)
 {
     __asm __volatile ("emms;":::"memory");
 }
+#endif
 
 
 #define emms_c() \
Index: libavcodec/i386/cputest.c
===================================================================
RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/i386/cputest.c,v
retrieving revision 1.8
diff -u -r1.8 cputest.c
--- libavcodec/i386/cputest.c	26 Nov 2002 16:26:58 -0000	1.8
+++ libavcodec/i386/cputest.c	26 Mar 2003 13:49:19 -0000
@@ -1,122 +1,13 @@
-/* Cpu detection code, extracted from mmx.h ((c)1997-99 by H. Dietz
-   and R. Fisher). Converted to C and improved by Fabrice Bellard */
+/* dummy file to use xine mm_support function */
 
-#include <stdlib.h>
+#include "xineutils.h"
 #include "../dsputil.h"
 
-/* ebx saving is necessary for PIC. gcc seems unable to see it alone */
-#define cpuid(index,eax,ebx,ecx,edx)\
-    __asm __volatile\
-	("movl %%ebx, %%esi\n\t"\
-         "cpuid\n\t"\
-         "xchgl %%ebx, %%esi"\
-         : "=a" (eax), "=S" (ebx),\
-           "=c" (ecx), "=d" (edx)\
-         : "0" (index));
 
 /* Function to test if multimedia instructions are supported...  */
 int mm_support(void)
 {
-    int rval;
-    int eax, ebx, ecx, edx;
-    
-    __asm__ __volatile__ (
-                          /* See if CPUID instruction is supported ... */
-                          /* ... Get copies of EFLAGS into eax and ecx */
-                          "pushf\n\t"
-                          "popl %0\n\t"
-                          "movl %0, %1\n\t"
-                          
-                          /* ... Toggle the ID bit in one copy and store */
-                          /*     to the EFLAGS reg */
-                          "xorl $0x200000, %0\n\t"
-                          "push %0\n\t"
-                          "popf\n\t"
-                          
-                          /* ... Get the (hopefully modified) EFLAGS */
-                          "pushf\n\t"
-                          "popl %0\n\t"
-                          : "=a" (eax), "=c" (ecx)
-                          :
-                          : "cc" 
-                          );
-    
-    if (eax == ecx)
-        return 0; /* CPUID not supported */
-    
-    cpuid(0, eax, ebx, ecx, edx);
-
-    if (ebx == 0x756e6547 &&
-        edx == 0x49656e69 &&
-        ecx == 0x6c65746e) {
-        
-        /* intel */
-    inteltest:
-        cpuid(1, eax, ebx, ecx, edx);
-        if ((edx & 0x00800000) == 0)
-            return 0;
-        rval = MM_MMX;
-        if (edx & 0x02000000) 
-            rval |= MM_MMXEXT | MM_SSE;
-        if (edx & 0x04000000) 
-            rval |= MM_SSE2;
-        return rval;
-    } else if (ebx == 0x68747541 &&
-               edx == 0x69746e65 &&
-               ecx == 0x444d4163) {
-        /* AMD */
-        cpuid(0x80000000, eax, ebx, ecx, edx);
-        if ((unsigned)eax < 0x80000001)
-            goto inteltest;
-        cpuid(0x80000001, eax, ebx, ecx, edx);
-        if ((edx & 0x00800000) == 0)
-            return 0;
-        rval = MM_MMX;
-        if (edx & 0x80000000)
-            rval |= MM_3DNOW;
-        if (edx & 0x00400000)
-            rval |= MM_MMXEXT;
-        return rval;
-    } else if (ebx == 0x746e6543 &&
-               edx == 0x48727561 &&
-               ecx == 0x736c7561) {  /*  "CentaurHauls" */
-        /* VIA C3 */
-        cpuid(0x80000000, eax, ebx, ecx, edx);
-        if ((unsigned)eax < 0x80000001)
-            goto inteltest;	
-	cpuid(0x80000001, eax, ebx, ecx, edx);
-	rval = 0;      
-	if( edx & ( 1 << 31) )
-	  rval |= MM_3DNOW;
-	if( edx & ( 1 << 23) )
-	  rval |= MM_MMX;
-	if( edx & ( 1 << 24) )
-	  rval |= MM_MMXEXT;
-	return rval;
-    } else if (ebx == 0x69727943 &&
-               edx == 0x736e4978 &&
-               ecx == 0x64616574) {
-        /* Cyrix Section */
-        /* See if extended CPUID level 80000001 is supported */
-        /* The value of CPUID/80000001 for the 6x86MX is undefined
-           according to the Cyrix CPU Detection Guide (Preliminary
-           Rev. 1.01 table 1), so we'll check the value of eax for
-           CPUID/0 to see if standard CPUID level 2 is supported.
-           According to the table, the only CPU which supports level
-           2 is also the only one which supports extended CPUID levels.
-        */
-        if (eax != 2) 
-            goto inteltest;
-        cpuid(0x80000001, eax, ebx, ecx, edx);
-        if ((eax & 0x00800000) == 0)
-            return 0;
-        rval = MM_MMX;
-        if (eax & 0x01000000)
-            rval |= MM_MMXEXT;
-        return rval;
-    } else {
-        return 0;
-    }
+  return xine_mm_accel();
 }
 
 #ifdef __TEST__
Index: libavcodec/i386/mmx.h
===================================================================
RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/i386/mmx.h,v
retrieving revision 1.3
diff -u -r1.3 mmx.h
--- libavcodec/i386/mmx.h	27 May 2002 08:31:54 -0000	1.3
+++ libavcodec/i386/mmx.h	26 Mar 2003 13:49:19 -0000
@@ -1,243 +1 @@
-/*
- * mmx.h
- * Copyright (C) 1997-2001 H. Dietz and R. Fisher
- */
-#ifndef AVCODEC_I386MMX_H
-#define AVCODEC_I386MMX_H
-
-/*
- * The type of an value that fits in an MMX register (note that long
- * long constant values MUST be suffixed by LL and unsigned long long
- * values by ULL, lest they be truncated by the compiler)
- */
-
-typedef	union {
-	long long		q;	/* Quadword (64-bit) value */
-	unsigned long long	uq;	/* Unsigned Quadword */
-	int			d[2];	/* 2 Doubleword (32-bit) values */
-	unsigned int		ud[2];	/* 2 Unsigned Doubleword */
-	short			w[4];	/* 4 Word (16-bit) values */
-	unsigned short		uw[4];	/* 4 Unsigned Word */
-	char			b[8];	/* 8 Byte (8-bit) values */
-	unsigned char		ub[8];	/* 8 Unsigned Byte */
-	float			s[2];	/* Single-precision (32-bit) value */
-} mmx_t;	/* On an 8-byte (64-bit) boundary */
-
-
-#define	mmx_i2r(op,imm,reg) \
-	__asm__ __volatile__ (#op " %0, %%" #reg \
-			      : /* nothing */ \
-			      : "i" (imm) )
-
-#define	mmx_m2r(op,mem,reg) \
-	__asm__ __volatile__ (#op " %0, %%" #reg \
-			      : /* nothing */ \
-			      : "m" (mem))
-
-#define	mmx_r2m(op,reg,mem) \
-	__asm__ __volatile__ (#op " %%" #reg ", %0" \
-			      : "=m" (mem) \
-			      : /* nothing */ )
-
-#define	mmx_r2r(op,regs,regd) \
-	__asm__ __volatile__ (#op " %" #regs ", %" #regd)
-
-
-#define	emms() __asm__ __volatile__ ("emms")
-
-#define	movd_m2r(var,reg)	mmx_m2r (movd, var, reg)
-#define	movd_r2m(reg,var)	mmx_r2m (movd, reg, var)
-#define	movd_r2r(regs,regd)	mmx_r2r (movd, regs, regd)
-
-#define	movq_m2r(var,reg)	mmx_m2r (movq, var, reg)
-#define	movq_r2m(reg,var)	mmx_r2m (movq, reg, var)
-#define	movq_r2r(regs,regd)	mmx_r2r (movq, regs, regd)
-
-#define	packssdw_m2r(var,reg)	mmx_m2r (packssdw, var, reg)
-#define	packssdw_r2r(regs,regd) mmx_r2r (packssdw, regs, regd)
-#define	packsswb_m2r(var,reg)	mmx_m2r (packsswb, var, reg)
-#define	packsswb_r2r(regs,regd) mmx_r2r (packsswb, regs, regd)
-
-#define	packuswb_m2r(var,reg)	mmx_m2r (packuswb, var, reg)
-#define	packuswb_r2r(regs,regd) mmx_r2r (packuswb, regs, regd)
-
-#define	paddb_m2r(var,reg)	mmx_m2r (paddb, var, reg)
-#define	paddb_r2r(regs,regd)	mmx_r2r (paddb, regs, regd)
-#define	paddd_m2r(var,reg)	mmx_m2r (paddd, var, reg)
-#define	paddd_r2r(regs,regd)	mmx_r2r (paddd, regs, regd)
-#define	paddw_m2r(var,reg)	mmx_m2r (paddw, var, reg)
-#define	paddw_r2r(regs,regd)	mmx_r2r (paddw, regs, regd)
-
-#define	paddsb_m2r(var,reg)	mmx_m2r (paddsb, var, reg)
-#define	paddsb_r2r(regs,regd)	mmx_r2r (paddsb, regs, regd)
-#define	paddsw_m2r(var,reg)	mmx_m2r (paddsw, var, reg)
-#define	paddsw_r2r(regs,regd)	mmx_r2r (paddsw, regs, regd)
-
-#define	paddusb_m2r(var,reg)	mmx_m2r (paddusb, var, reg)
-#define	paddusb_r2r(regs,regd)	mmx_r2r (paddusb, regs, regd)
-#define	paddusw_m2r(var,reg)	mmx_m2r (paddusw, var, reg)
-#define	paddusw_r2r(regs,regd)	mmx_r2r (paddusw, regs, regd)
-
-#define	pand_m2r(var,reg)	mmx_m2r (pand, var, reg)
-#define	pand_r2r(regs,regd)	mmx_r2r (pand, regs, regd)
-
-#define	pandn_m2r(var,reg)	mmx_m2r (pandn, var, reg)
-#define	pandn_r2r(regs,regd)	mmx_r2r (pandn, regs, regd)
-
-#define	pcmpeqb_m2r(var,reg)	mmx_m2r (pcmpeqb, var, reg)
-#define	pcmpeqb_r2r(regs,regd)	mmx_r2r (pcmpeqb, regs, regd)
-#define	pcmpeqd_m2r(var,reg)	mmx_m2r (pcmpeqd, var, reg)
-#define	pcmpeqd_r2r(regs,regd)	mmx_r2r (pcmpeqd, regs, regd)
-#define	pcmpeqw_m2r(var,reg)	mmx_m2r (pcmpeqw, var, reg)
-#define	pcmpeqw_r2r(regs,regd)	mmx_r2r (pcmpeqw, regs, regd)
-
-#define	pcmpgtb_m2r(var,reg)	mmx_m2r (pcmpgtb, var, reg)
-#define	pcmpgtb_r2r(regs,regd)	mmx_r2r (pcmpgtb, regs, regd)
-#define	pcmpgtd_m2r(var,reg)	mmx_m2r (pcmpgtd, var, reg)
-#define	pcmpgtd_r2r(regs,regd)	mmx_r2r (pcmpgtd, regs, regd)
-#define	pcmpgtw_m2r(var,reg)	mmx_m2r (pcmpgtw, var, reg)
-#define	pcmpgtw_r2r(regs,regd)	mmx_r2r (pcmpgtw, regs, regd)
-
-#define	pmaddwd_m2r(var,reg)	mmx_m2r (pmaddwd, var, reg)
-#define	pmaddwd_r2r(regs,regd)	mmx_r2r (pmaddwd, regs, regd)
-
-#define	pmulhw_m2r(var,reg)	mmx_m2r (pmulhw, var, reg)
-#define	pmulhw_r2r(regs,regd)	mmx_r2r (pmulhw, regs, regd)
-
-#define	pmullw_m2r(var,reg)	mmx_m2r (pmullw, var, reg)
-#define	pmullw_r2r(regs,regd)	mmx_r2r (pmullw, regs, regd)
-
-#define	por_m2r(var,reg)	mmx_m2r (por, var, reg)
-#define	por_r2r(regs,regd)	mmx_r2r (por, regs, regd)
-
-#define	pslld_i2r(imm,reg)	mmx_i2r (pslld, imm, reg)
-#define	pslld_m2r(var,reg)	mmx_m2r (pslld, var, reg)
-#define	pslld_r2r(regs,regd)	mmx_r2r (pslld, regs, regd)
-#define	psllq_i2r(imm,reg)	mmx_i2r (psllq, imm, reg)
-#define	psllq_m2r(var,reg)	mmx_m2r (psllq, var, reg)
-#define	psllq_r2r(regs,regd)	mmx_r2r (psllq, regs, regd)
-#define	psllw_i2r(imm,reg)	mmx_i2r (psllw, imm, reg)
-#define	psllw_m2r(var,reg)	mmx_m2r (psllw, var, reg)
-#define	psllw_r2r(regs,regd)	mmx_r2r (psllw, regs, regd)
-
-#define	psrad_i2r(imm,reg)	mmx_i2r (psrad, imm, reg)
-#define	psrad_m2r(var,reg)	mmx_m2r (psrad, var, reg)
-#define	psrad_r2r(regs,regd)	mmx_r2r (psrad, regs, regd)
-#define	psraw_i2r(imm,reg)	mmx_i2r (psraw, imm, reg)
-#define	psraw_m2r(var,reg)	mmx_m2r (psraw, var, reg)
-#define	psraw_r2r(regs,regd)	mmx_r2r (psraw, regs, regd)
-
-#define	psrld_i2r(imm,reg)	mmx_i2r (psrld, imm, reg)
-#define	psrld_m2r(var,reg)	mmx_m2r (psrld, var, reg)
-#define	psrld_r2r(regs,regd)	mmx_r2r (psrld, regs, regd)
-#define	psrlq_i2r(imm,reg)	mmx_i2r (psrlq, imm, reg)
-#define	psrlq_m2r(var,reg)	mmx_m2r (psrlq, var, reg)
-#define	psrlq_r2r(regs,regd)	mmx_r2r (psrlq, regs, regd)
-#define	psrlw_i2r(imm,reg)	mmx_i2r (psrlw, imm, reg)
-#define	psrlw_m2r(var,reg)	mmx_m2r (psrlw, var, reg)
-#define	psrlw_r2r(regs,regd)	mmx_r2r (psrlw, regs, regd)
-
-#define	psubb_m2r(var,reg)	mmx_m2r (psubb, var, reg)
-#define	psubb_r2r(regs,regd)	mmx_r2r (psubb, regs, regd)
-#define	psubd_m2r(var,reg)	mmx_m2r (psubd, var, reg)
-#define	psubd_r2r(regs,regd)	mmx_r2r (psubd, regs, regd)
-#define	psubw_m2r(var,reg)	mmx_m2r (psubw, var, reg)
-#define	psubw_r2r(regs,regd)	mmx_r2r (psubw, regs, regd)
-
-#define	psubsb_m2r(var,reg)	mmx_m2r (psubsb, var, reg)
-#define	psubsb_r2r(regs,regd)	mmx_r2r (psubsb, regs, regd)
-#define	psubsw_m2r(var,reg)	mmx_m2r (psubsw, var, reg)
-#define	psubsw_r2r(regs,regd)	mmx_r2r (psubsw, regs, regd)
-
-#define	psubusb_m2r(var,reg)	mmx_m2r (psubusb, var, reg)
-#define	psubusb_r2r(regs,regd)	mmx_r2r (psubusb, regs, regd)
-#define	psubusw_m2r(var,reg)	mmx_m2r (psubusw, var, reg)
-#define	psubusw_r2r(regs,regd)	mmx_r2r (psubusw, regs, regd)
-
-#define	punpckhbw_m2r(var,reg)		mmx_m2r (punpckhbw, var, reg)
-#define	punpckhbw_r2r(regs,regd)	mmx_r2r (punpckhbw, regs, regd)
-#define	punpckhdq_m2r(var,reg)		mmx_m2r (punpckhdq, var, reg)
-#define	punpckhdq_r2r(regs,regd)	mmx_r2r (punpckhdq, regs, regd)
-#define	punpckhwd_m2r(var,reg)		mmx_m2r (punpckhwd, var, reg)
-#define	punpckhwd_r2r(regs,regd)	mmx_r2r (punpckhwd, regs, regd)
-
-#define	punpcklbw_m2r(var,reg) 		mmx_m2r (punpcklbw, var, reg)
-#define	punpcklbw_r2r(regs,regd)	mmx_r2r (punpcklbw, regs, regd)
-#define	punpckldq_m2r(var,reg)		mmx_m2r (punpckldq, var, reg)
-#define	punpckldq_r2r(regs,regd)	mmx_r2r (punpckldq, regs, regd)
-#define	punpcklwd_m2r(var,reg)		mmx_m2r (punpcklwd, var, reg)
-#define	punpcklwd_r2r(regs,regd)	mmx_r2r (punpcklwd, regs, regd)
-
-#define	pxor_m2r(var,reg)	mmx_m2r (pxor, var, reg)
-#define	pxor_r2r(regs,regd)	mmx_r2r (pxor, regs, regd)
-
-
-/* 3DNOW extensions */
-
-#define pavgusb_m2r(var,reg)	mmx_m2r (pavgusb, var, reg)
-#define pavgusb_r2r(regs,regd)	mmx_r2r (pavgusb, regs, regd)
-
-
-/* AMD MMX extensions - also available in intel SSE */
-
-
-#define mmx_m2ri(op,mem,reg,imm) \
-        __asm__ __volatile__ (#op " %1, %0, %%" #reg \
-                              : /* nothing */ \
-                              : "X" (mem), "X" (imm))
-#define mmx_r2ri(op,regs,regd,imm) \
-        __asm__ __volatile__ (#op " %0, %%" #regs ", %%" #regd \
-                              : /* nothing */ \
-                              : "X" (imm) )
-
-#define	mmx_fetch(mem,hint) \
-	__asm__ __volatile__ ("prefetch" #hint " %0" \
-			      : /* nothing */ \
-			      : "X" (mem))
-
-
-#define	maskmovq(regs,maskreg)		mmx_r2ri (maskmovq, regs, maskreg)
-
-#define	movntq_r2m(mmreg,var)		mmx_r2m (movntq, mmreg, var)
-
-#define	pavgb_m2r(var,reg)		mmx_m2r (pavgb, var, reg)
-#define	pavgb_r2r(regs,regd)		mmx_r2r (pavgb, regs, regd)
-#define	pavgw_m2r(var,reg)		mmx_m2r (pavgw, var, reg)
-#define	pavgw_r2r(regs,regd)		mmx_r2r (pavgw, regs, regd)
-
-#define	pextrw_r2r(mmreg,reg,imm)	mmx_r2ri (pextrw, mmreg, reg, imm)
-
-#define	pinsrw_r2r(reg,mmreg,imm)	mmx_r2ri (pinsrw, reg, mmreg, imm)
-
-#define	pmaxsw_m2r(var,reg)		mmx_m2r (pmaxsw, var, reg)
-#define	pmaxsw_r2r(regs,regd)		mmx_r2r (pmaxsw, regs, regd)
-
-#define	pmaxub_m2r(var,reg)		mmx_m2r (pmaxub, var, reg)
-#define	pmaxub_r2r(regs,regd)		mmx_r2r (pmaxub, regs, regd)
-
-#define	pminsw_m2r(var,reg)		mmx_m2r (pminsw, var, reg)
-#define	pminsw_r2r(regs,regd)		mmx_r2r (pminsw, regs, regd)
-
-#define	pminub_m2r(var,reg)		mmx_m2r (pminub, var, reg)
-#define	pminub_r2r(regs,regd)		mmx_r2r (pminub, regs, regd)
-
-#define	pmovmskb(mmreg,reg) \
-	__asm__ __volatile__ ("movmskps %" #mmreg ", %" #reg)
-
-#define	pmulhuw_m2r(var,reg)		mmx_m2r (pmulhuw, var, reg)
-#define	pmulhuw_r2r(regs,regd)		mmx_r2r (pmulhuw, regs, regd)
-
-#define	prefetcht0(mem)			mmx_fetch (mem, t0)
-#define	prefetcht1(mem)			mmx_fetch (mem, t1)
-#define	prefetcht2(mem)			mmx_fetch (mem, t2)
-#define	prefetchnta(mem)		mmx_fetch (mem, nta)
-
-#define	psadbw_m2r(var,reg)		mmx_m2r (psadbw, var, reg)
-#define	psadbw_r2r(regs,regd)		mmx_r2r (psadbw, regs, regd)
-
-#define	pshufw_m2r(var,reg,imm)		mmx_m2ri(pshufw, var, reg, imm)
-#define	pshufw_r2r(regs,regd,imm)	mmx_r2ri(pshufw, regs, regd, imm)
-
-#define	sfence() __asm__ __volatile__ ("sfence\n\t")
-
-#endif /* AVCODEC_I386MMX_H */
+#include "xineutils.h"
Index: libavcodec/libpostproc/postprocess.c
===================================================================
RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/libpostproc/postprocess.c,v
retrieving revision 1.83
diff -u -r1.83 postprocess.c
--- libavcodec/libpostproc/postprocess.c	6 Mar 2003 13:51:18 -0000	1.83
+++ libavcodec/libpostproc/postprocess.c	26 Mar 2003 13:49:20 -0000
@@ -70,8 +70,9 @@
 #include "config.h"
 #include <inttypes.h>
 #include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
+
+#include "xineutils.h"
+
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
@@ -80,9 +81,9 @@
 //#undef HAVE_MMX
 //#undef ARCH_X86
 //#define DEBUG_BRIGHTNESS
-#ifdef USE_FASTMEMCPY
-#include "libvo/fastmemcpy.h"
-#endif
+
+#define memcpy(a,b,c) xine_fast_memcpy(a,b,c)
+
 #include "postprocess.h"
 #include "postprocess_internal.h"
 
@@ -104,13 +105,13 @@
 //#define NUM_BLOCKS_AT_ONCE 16 //not used yet
 
 #ifdef ARCH_X86
-static uint64_t __attribute__((aligned(8))) w05=		0x0005000500050005LL;
-static uint64_t __attribute__((aligned(8))) w20=		0x0020002000200020LL;
-static uint64_t __attribute__((aligned(8))) b00= 		0x0000000000000000LL;
-static uint64_t __attribute__((aligned(8))) b01= 		0x0101010101010101LL;
-static uint64_t __attribute__((aligned(8))) b02= 		0x0202020202020202LL;
-static uint64_t __attribute__((aligned(8))) b08= 		0x0808080808080808LL;
-static uint64_t __attribute__((aligned(8))) b80= 		0x8080808080808080LL;
+static const uint64_t __attribute__((aligned(8))) w05=		0x0005000500050005LL;
+static const uint64_t __attribute__((aligned(8))) w20=		0x0020002000200020LL;
+             uint64_t __attribute__((aligned(8))) b00= 		0x0000000000000000LL;
+static const uint64_t __attribute__((aligned(8))) b01= 		0x0101010101010101LL;
+static const uint64_t __attribute__((aligned(8))) b02= 		0x0202020202020202LL;
+static const uint64_t __attribute__((aligned(8))) b08= 		0x0808080808080808LL;
+static const uint64_t __attribute__((aligned(8))) b80= 		0x8080808080808080LL;
 #endif
 
 
@@ -159,37 +160,6 @@
 }
 #endif
 
-
-#ifdef ARCH_X86
-static inline void prefetchnta(void *p)
-{
-	asm volatile(	"prefetchnta (%0)\n\t"
-		: : "r" (p)
-	);
-}
-
-static inline void prefetcht0(void *p)
-{
-	asm volatile(	"prefetcht0 (%0)\n\t"
-		: : "r" (p)
-	);
-}
-
-static inline void prefetcht1(void *p)
-{
-	asm volatile(	"prefetcht1 (%0)\n\t"
-		: : "r" (p)
-	);
-}
-
-static inline void prefetcht2(void *p)
-{
-	asm volatile(	"prefetcht2 (%0)\n\t"
-		: : "r" (p)
-	);
-}
-#endif
-
 // The horizontal Functions exist only in C cuz the MMX code is faster with vertical filters and transposing
 
 /**
Index: libavcodec/mjpeg.c
===================================================================
RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/mjpeg.c,v
retrieving revision 1.61
diff -u -r1.61 mjpeg.c
--- libavcodec/mjpeg.c	23 May 2003 16:04:24 -0000	1.61
+++ libavcodec/mjpeg.c	23 May 2003 18:18:53 -0000
@@ -1471,7 +1471,7 @@
 	    4bytes	field_size
 	    4bytes	field_size_less_padding
 	*/
-    	s->buggy_avid = 1;
+//    	s->buggy_avid = 1;
 //	if (s->first_picture)
 //	    printf("mjpeg: workarounding buggy AVID\n");
 	s->interlace_polarity = get_bits(&s->gb, 8);
Index: libavcodec/mpegvideo.c
===================================================================
RCS file: /cvsroot/xine/xine-lib/src/libffmpeg/libavcodec/mpegvideo.c,v
retrieving revision 1.31
diff -u -r1.31 mpegvideo.c
--- libavcodec/mpegvideo.c	9 May 2003 23:54:05 -0000	1.31
+++ libavcodec/mpegvideo.c	25 May 2003 18:29:52 -0000
@@ -763,7 +763,9 @@
     if (MPV_common_init(s) < 0)
         return -1;
     
+#ifdef CONFIG_ENCODERS_FULL
     ff_init_me(s);
+#endif
 
 #ifdef CONFIG_ENCODERS
 #ifdef CONFIG_RISKY
@@ -1550,8 +1552,10 @@
         if (s->out_format == FMT_MJPEG)
             mjpeg_picture_trailer(s);
         
+#ifdef CONFIG_ENCODERS_FULL
         if(s->flags&CODEC_FLAG_PASS1)
             ff_write_pass1_stats(s);
+#endif
 
         for(i=0; i<4; i++){
             avctx->error[i] += s->current_picture_ptr->error[i];
@@ -3137,6 +3141,7 @@
     /* Estimate motion for every MB */
     s->mb_intra=0; //for the rate distoration & bit compare functions
     if(s->pict_type != I_TYPE){
+#ifdef CONFIG_ENCODERS_FULL
         if(s->pict_type != B_TYPE){
             if((s->avctx->pre_me && s->last_non_b_pict_type==I_TYPE) || s->avctx->pre_me==2){
                 s->me.pre_pass=1;
@@ -3174,6 +3179,7 @@
                     ff_estimate_p_frame_motion(s, mb_x, mb_y);
             }
         }
+#endif
     }else /* if(s->pict_type == I_TYPE) */{
         /* I-Frame */
         //FIXME do we need to zero them?
@@ -3208,6 +3214,7 @@
 //printf("Scene change detected, encoding as I Frame %d %d\n", s->current_picture.mb_var_sum, s->current_picture.mc_mb_var_sum);
     }
 
+#ifdef CONFIG_ENCODERS_FULL
     if(!s->umvplus){
         if(s->pict_type==P_TYPE || s->pict_type==S_TYPE) {
             s->f_code= ff_get_best_fcode(s, s->p_mv_table, MB_TYPE_INTER);
@@ -3232,6 +3239,7 @@
             ff_fix_long_b_mvs(s, s->b_bidir_back_mv_table, s->b_code, MB_TYPE_BIDIR);
         }
     }
+#endif
     
     if (s->fixed_qscale) 
         s->frame_qscale = s->current_picture.quality;
Index: libavcodec/h263.c
===================================================================
RCS file: /cvsroot/xine/xine-lib/src/libffmpeg/libavcodec/h263.c,v
retrieving revision 1.29
diff -u -r1.29 h263.c
--- libavcodec/h263.c	19 Jun 2003 00:47:19 -0000	1.29
+++ libavcodec/h263.c	27 Jun 2003 13:51:30 -0000
@@ -4606,6 +4606,7 @@
         s->divx_version= ver;
         s->divx_build= build;
         s->divx_packed= e==3 && last=='p';
+#if 0
         if(s->picture_number==0){
             printf("This file was encoded with DivX%d Build%d", ver, build);
             if(s->divx_packed)
@@ -4613,6 +4614,7 @@
             else
                 printf("\n");
         }
+#endif
     }
     
     /* ffmpeg detection */
@@ -4628,16 +4630,20 @@
     if(e==4){
         s->ffmpeg_version= ver*256*256 + ver2*256 + ver3;
         s->lavc_build= build;
+#if 0
         if(s->picture_number==0)
             printf("This file was encoded with libavcodec build %d\n", build);
+#endif
     }
     
     /* xvid detection */
     e=sscanf(buf, "XviD%d", &build);
     if(e==1){
         s->xvid_build= build;
+#if 0
         if(s->picture_number==0)
             printf("This file was encoded with XviD build %d\n", build);
+#endif
     }
 
 //printf("User Data: %s\n", buf);
Index: libavcodec/i386/motion_est_mmx.c
===================================================================
RCS file: /cvsroot/xine/xine-lib/src/libffmpeg/libavcodec/i386/motion_est_mmx.c,v
retrieving revision 1.8
diff -u -r1.8 motion_est_mmx.c
--- libavcodec/i386/motion_est_mmx.c	26 Mar 2003 14:44:17 -0000	1.8
+++ libavcodec/i386/motion_est_mmx.c	2 Jul 2003 14:31:19 -0000
@@ -26,7 +26,7 @@
 0x0002000200020002,
 };
 
-static __attribute__ ((aligned(8))) uint64_t bone= 0x0101010101010101LL;
+static const __attribute__ ((aligned(8))) uint64_t bone= 0x0101010101010101LL;
 
 static inline void sad8_mmx(uint8_t *blk1, uint8_t *blk2, int stride, int h)
 {
