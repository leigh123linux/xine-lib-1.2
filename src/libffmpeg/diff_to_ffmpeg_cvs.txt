--- libavcodec/avcodec.h	2003-10-30 07:00:25.000000000 +0100
+++ libavcodec/avcodec.h	2003-11-01 18:34:59.000000000 +0100
@@ -14,6 +14,13 @@
 #include "common.h"
 #include "rational.h"
 
+/* FIXME: We cannot use ffmpeg's XvMC capabilities, since that would require
+ * linking the ffmpeg plugin against XvMC libraries, which is a bad thing,
+ * since they are output dependend.
+ * The correct fix would be to reimplement the XvMC functions libavcodec uses
+ * and do the necessary talking with our XvMC output plugin there. */
+#undef HAVE_XVMC
+
 #define FFMPEG_VERSION_INT     0x000408
 #define FFMPEG_VERSION         "0.4.8"
 #define LIBAVCODEC_BUILD       4688
--- libavcodec/cinepak.c	2003-10-27 16:24:38.000000000 +0100
+++ libavcodec/cinepak.c	2003-10-28 21:01:06.000000000 +0100
@@ -37,6 +37,9 @@
 
 #define PALETTE_COUNT 256
 
+#undef BE_16
+#undef BE_32
+
 #define BE_16(x)  ((((uint8_t*)(x))[0] << 8) | ((uint8_t*)(x))[1])
 #define BE_32(x)  ((((uint8_t*)(x))[0] << 24) | \
                    (((uint8_t*)(x))[1] << 16) | \
--- libavcodec/common.c	2003-10-27 16:24:38.000000000 +0100
+++ libavcodec/common.c	2003-10-27 19:42:02.000000000 +0100
@@ -60,7 +60,7 @@
 #endif
 }
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 
 /* return the number of bits output */
 int64_t get_bit_count(PutBitContext *s)
@@ -101,7 +101,7 @@
 #endif
 }
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 
 void put_string(PutBitContext * pbc, char *s)
 {
--- libavcodec/common.h	2003-11-01 18:43:19.000000000 +0100
+++ libavcodec/common.h	2003-10-27 19:42:02.000000000 +0100
@@ -184,11 +184,19 @@
 
 #    else
 
-#        ifdef DEBUG
-#            define dprintf(fmt,...) printf(fmt, __VA_ARGS__)
-#        else
-#            define dprintf(fmt,...)
-#        endif
+#if __GNUC__
+#ifdef DEBUG
+#define dprintf(fmt,args...) printf(fmt, ## args)
+#else
+#define dprintf(fmt,args...)
+#endif
+#else
+#ifdef DEBUG
+#define dprintf(...) printf(__VA_ARGS__)
+#else
+#define dprintf(...)
+#endif
+#endif
 
 #    endif /* !CONFIG_WIN32 */
 
--- libavcodec/dpcm.c	2003-10-27 16:24:38.000000000 +0100
+++ libavcodec/dpcm.c	2003-10-28 21:01:51.000000000 +0100
@@ -44,6 +44,10 @@
 #define SATURATE_S16(x)  if (x < -32768) x = -32768; \
   else if (x > 32767) x = 32767;
 #define SE_16BIT(x)  if (x & 0x8000) x -= 0x10000;
+
+#undef LE_16
+#undef LE_32
+
 #define LE_16(x)  ((((uint8_t*)(x))[1] << 8) | ((uint8_t*)(x))[0])
 #define LE_32(x)  ((((uint8_t*)(x))[3] << 24) | \
                    (((uint8_t*)(x))[2] << 16) | \
--- libavcodec/dsputil.h	2003-11-01 18:43:19.000000000 +0100
+++ libavcodec/dsputil.h	2003-10-27 19:42:02.000000000 +0100
@@ -29,9 +29,14 @@
 
 #include "common.h"
 #include "avcodec.h"
+#include "xineutils.h"
 
+#if defined(ARCH_X86)
+#define HAVE_MMX 1 
+#endif
+
+#undef DEBUG
 
-//#define DEBUG
 /* dct code */
 typedef short DCTELEM;
 
@@ -317,21 +322,25 @@
 
 #undef emms_c
 
+#if 0
 #define MM_MMX    0x0001 /* standard MMX */
 #define MM_3DNOW  0x0004 /* AMD 3DNOW */
 #define MM_MMXEXT 0x0002 /* SSE integer functions or AMD MMX ext */
 #define MM_SSE    0x0008 /* SSE functions */
 #define MM_SSE2   0x0010 /* PIV SSE2 functions */
+#endif
 
 extern int mm_flags;
 
 void add_pixels_clamped_mmx(const DCTELEM *block, uint8_t *pixels, int line_size);
 void put_pixels_clamped_mmx(const DCTELEM *block, uint8_t *pixels, int line_size);
 
+#if 0 
 static inline void emms(void)
 {
     __asm __volatile ("emms;":::"memory");
 }
+#endif
 
 
 #define emms_c() \
--- libavcodec/fastmemcpy.h	2003-11-01 18:43:19.000000000 +0100
+++ libavcodec/fastmemcpy.h	2003-04-16 02:18:37.000000000 +0200
@@ -1 +1,8 @@
-#include "../libvo/fastmemcpy.h"
+#ifndef __FASTMEMCPY_H__
+#define __FASTMEMCPY_H__
+
+#include "xineutils.h"
+
+#define memcpy(a,b,c) xine_fast_memcpy(a,b,c)
+
+#endif
--- libavcodec/h263.c	2003-11-16 16:02:21.000000000 +0100
+++ libavcodec/h263.c	2003-12-06 16:53:35.000000000 +0100
@@ -5097,7 +5097,7 @@
      /* detect buggy encoders which dont set the low_delay flag (divx4/xvid/opendivx)*/
      // note we cannot detect divx5 without b-frames easyly (allthough its buggy too)
      if(s->vo_type==0 && s->vol_control_parameters==0 && s->divx_version==0 && s->picture_number==0){
-         printf("looks like this file was encoded with (divx4/(old)xvid/opendivx) -> forcing low_delay flag\n");
+         //printf("looks like this file was encoded with (divx4/(old)xvid/opendivx) -> forcing low_delay flag\n");
          s->low_delay=1;
      }
 
--- libavcodec/i386/cputest.c	2003-11-01 18:43:19.000000000 +0100
+++ libavcodec/i386/cputest.c	2003-07-02 16:36:41.000000000 +0200
@@ -1,122 +1,13 @@
-/* Cpu detection code, extracted from mmx.h ((c)1997-99 by H. Dietz
-   and R. Fisher). Converted to C and improved by Fabrice Bellard */
+/* dummy file to use xine mm_support function */
 
-#include <stdlib.h>
+#include "xineutils.h"
 #include "../dsputil.h"
 
-/* ebx saving is necessary for PIC. gcc seems unable to see it alone */
-#define cpuid(index,eax,ebx,ecx,edx)\
-    __asm __volatile\
-	("movl %%ebx, %%esi\n\t"\
-         "cpuid\n\t"\
-         "xchgl %%ebx, %%esi"\
-         : "=a" (eax), "=S" (ebx),\
-           "=c" (ecx), "=d" (edx)\
-         : "0" (index));
 
 /* Function to test if multimedia instructions are supported...  */
 int mm_support(void)
 {
-    int rval;
-    int eax, ebx, ecx, edx;
-    
-    __asm__ __volatile__ (
-                          /* See if CPUID instruction is supported ... */
-                          /* ... Get copies of EFLAGS into eax and ecx */
-                          "pushf\n\t"
-                          "popl %0\n\t"
-                          "movl %0, %1\n\t"
-                          
-                          /* ... Toggle the ID bit in one copy and store */
-                          /*     to the EFLAGS reg */
-                          "xorl $0x200000, %0\n\t"
-                          "push %0\n\t"
-                          "popf\n\t"
-                          
-                          /* ... Get the (hopefully modified) EFLAGS */
-                          "pushf\n\t"
-                          "popl %0\n\t"
-                          : "=a" (eax), "=c" (ecx)
-                          :
-                          : "cc" 
-                          );
-    
-    if (eax == ecx)
-        return 0; /* CPUID not supported */
-    
-    cpuid(0, eax, ebx, ecx, edx);
-
-    if (ebx == 0x756e6547 &&
-        edx == 0x49656e69 &&
-        ecx == 0x6c65746e) {
-        
-        /* intel */
-    inteltest:
-        cpuid(1, eax, ebx, ecx, edx);
-        if ((edx & 0x00800000) == 0)
-            return 0;
-        rval = MM_MMX;
-        if (edx & 0x02000000) 
-            rval |= MM_MMXEXT | MM_SSE;
-        if (edx & 0x04000000) 
-            rval |= MM_SSE2;
-        return rval;
-    } else if (ebx == 0x68747541 &&
-               edx == 0x69746e65 &&
-               ecx == 0x444d4163) {
-        /* AMD */
-        cpuid(0x80000000, eax, ebx, ecx, edx);
-        if ((unsigned)eax < 0x80000001)
-            goto inteltest;
-        cpuid(0x80000001, eax, ebx, ecx, edx);
-        if ((edx & 0x00800000) == 0)
-            return 0;
-        rval = MM_MMX;
-        if (edx & 0x80000000)
-            rval |= MM_3DNOW;
-        if (edx & 0x00400000)
-            rval |= MM_MMXEXT;
-        return rval;
-    } else if (ebx == 0x746e6543 &&
-               edx == 0x48727561 &&
-               ecx == 0x736c7561) {  /*  "CentaurHauls" */
-        /* VIA C3 */
-        cpuid(0x80000000, eax, ebx, ecx, edx);
-        if ((unsigned)eax < 0x80000001)
-            goto inteltest;	
-	cpuid(0x80000001, eax, ebx, ecx, edx);
-	rval = 0;      
-	if( edx & ( 1 << 31) )
-	  rval |= MM_3DNOW;
-	if( edx & ( 1 << 23) )
-	  rval |= MM_MMX;
-	if( edx & ( 1 << 24) )
-	  rval |= MM_MMXEXT;
-	return rval;
-    } else if (ebx == 0x69727943 &&
-               edx == 0x736e4978 &&
-               ecx == 0x64616574) {
-        /* Cyrix Section */
-        /* See if extended CPUID level 80000001 is supported */
-        /* The value of CPUID/80000001 for the 6x86MX is undefined
-           according to the Cyrix CPU Detection Guide (Preliminary
-           Rev. 1.01 table 1), so we'll check the value of eax for
-           CPUID/0 to see if standard CPUID level 2 is supported.
-           According to the table, the only CPU which supports level
-           2 is also the only one which supports extended CPUID levels.
-        */
-        if (eax != 2) 
-            goto inteltest;
-        cpuid(0x80000001, eax, ebx, ecx, edx);
-        if ((eax & 0x00800000) == 0)
-            return 0;
-        rval = MM_MMX;
-        if (eax & 0x01000000)
-            rval |= MM_MMXEXT;
-        return rval;
-    } else {
-        return 0;
-    }
+  return xine_mm_accel();
 }
 
 #ifdef __TEST__
--- libavcodec/i386/fdct_mmx.c	2002-11-11 14:45:36.000000000 +0100
+++ libavcodec/i386/fdct_mmx.c	2003-10-24 14:04:32.000000000 +0200
@@ -10,6 +10,7 @@
 #include "../dsputil.h"
 #include "mmx.h"
 
+#undef ATTR_ALIGN
 #define ATTR_ALIGN(align) __attribute__ ((__aligned__ (align)))
 
 //////////////////////////////////////////////////////////////////////
--- libavcodec/i386/idct_mmx.c	2002-10-29 17:29:19.000000000 +0100
+++ libavcodec/i386/idct_mmx.c	2003-10-30 23:21:12.000000000 +0100
@@ -26,6 +26,7 @@
 
 #include "mmx.h"
 
+#undef ATTR_ALIGN
 #define ATTR_ALIGN(align) __attribute__ ((__aligned__ (align)))
 
 #define ROW_SHIFT 11
--- libavcodec/i386/mmx.h	2003-11-01 18:43:19.000000000 +0100
+++ libavcodec/i386/mmx.h	2003-07-02 16:36:41.000000000 +0200
@@ -1,243 +1 @@
-/*
- * mmx.h
- * Copyright (C) 1997-2001 H. Dietz and R. Fisher
- */
-#ifndef AVCODEC_I386MMX_H
-#define AVCODEC_I386MMX_H
-
-/*
- * The type of an value that fits in an MMX register (note that long
- * long constant values MUST be suffixed by LL and unsigned long long
- * values by ULL, lest they be truncated by the compiler)
- */
-
-typedef	union {
-	long long		q;	/* Quadword (64-bit) value */
-	unsigned long long	uq;	/* Unsigned Quadword */
-	int			d[2];	/* 2 Doubleword (32-bit) values */
-	unsigned int		ud[2];	/* 2 Unsigned Doubleword */
-	short			w[4];	/* 4 Word (16-bit) values */
-	unsigned short		uw[4];	/* 4 Unsigned Word */
-	char			b[8];	/* 8 Byte (8-bit) values */
-	unsigned char		ub[8];	/* 8 Unsigned Byte */
-	float			s[2];	/* Single-precision (32-bit) value */
-} mmx_t;	/* On an 8-byte (64-bit) boundary */
-
-
-#define	mmx_i2r(op,imm,reg) \
-	__asm__ __volatile__ (#op " %0, %%" #reg \
-			      : /* nothing */ \
-			      : "i" (imm) )
-
-#define	mmx_m2r(op,mem,reg) \
-	__asm__ __volatile__ (#op " %0, %%" #reg \
-			      : /* nothing */ \
-			      : "m" (mem))
-
-#define	mmx_r2m(op,reg,mem) \
-	__asm__ __volatile__ (#op " %%" #reg ", %0" \
-			      : "=m" (mem) \
-			      : /* nothing */ )
-
-#define	mmx_r2r(op,regs,regd) \
-	__asm__ __volatile__ (#op " %" #regs ", %" #regd)
-
-
-#define	emms() __asm__ __volatile__ ("emms")
-
-#define	movd_m2r(var,reg)	mmx_m2r (movd, var, reg)
-#define	movd_r2m(reg,var)	mmx_r2m (movd, reg, var)
-#define	movd_r2r(regs,regd)	mmx_r2r (movd, regs, regd)
-
-#define	movq_m2r(var,reg)	mmx_m2r (movq, var, reg)
-#define	movq_r2m(reg,var)	mmx_r2m (movq, reg, var)
-#define	movq_r2r(regs,regd)	mmx_r2r (movq, regs, regd)
-
-#define	packssdw_m2r(var,reg)	mmx_m2r (packssdw, var, reg)
-#define	packssdw_r2r(regs,regd) mmx_r2r (packssdw, regs, regd)
-#define	packsswb_m2r(var,reg)	mmx_m2r (packsswb, var, reg)
-#define	packsswb_r2r(regs,regd) mmx_r2r (packsswb, regs, regd)
-
-#define	packuswb_m2r(var,reg)	mmx_m2r (packuswb, var, reg)
-#define	packuswb_r2r(regs,regd) mmx_r2r (packuswb, regs, regd)
-
-#define	paddb_m2r(var,reg)	mmx_m2r (paddb, var, reg)
-#define	paddb_r2r(regs,regd)	mmx_r2r (paddb, regs, regd)
-#define	paddd_m2r(var,reg)	mmx_m2r (paddd, var, reg)
-#define	paddd_r2r(regs,regd)	mmx_r2r (paddd, regs, regd)
-#define	paddw_m2r(var,reg)	mmx_m2r (paddw, var, reg)
-#define	paddw_r2r(regs,regd)	mmx_r2r (paddw, regs, regd)
-
-#define	paddsb_m2r(var,reg)	mmx_m2r (paddsb, var, reg)
-#define	paddsb_r2r(regs,regd)	mmx_r2r (paddsb, regs, regd)
-#define	paddsw_m2r(var,reg)	mmx_m2r (paddsw, var, reg)
-#define	paddsw_r2r(regs,regd)	mmx_r2r (paddsw, regs, regd)
-
-#define	paddusb_m2r(var,reg)	mmx_m2r (paddusb, var, reg)
-#define	paddusb_r2r(regs,regd)	mmx_r2r (paddusb, regs, regd)
-#define	paddusw_m2r(var,reg)	mmx_m2r (paddusw, var, reg)
-#define	paddusw_r2r(regs,regd)	mmx_r2r (paddusw, regs, regd)
-
-#define	pand_m2r(var,reg)	mmx_m2r (pand, var, reg)
-#define	pand_r2r(regs,regd)	mmx_r2r (pand, regs, regd)
-
-#define	pandn_m2r(var,reg)	mmx_m2r (pandn, var, reg)
-#define	pandn_r2r(regs,regd)	mmx_r2r (pandn, regs, regd)
-
-#define	pcmpeqb_m2r(var,reg)	mmx_m2r (pcmpeqb, var, reg)
-#define	pcmpeqb_r2r(regs,regd)	mmx_r2r (pcmpeqb, regs, regd)
-#define	pcmpeqd_m2r(var,reg)	mmx_m2r (pcmpeqd, var, reg)
-#define	pcmpeqd_r2r(regs,regd)	mmx_r2r (pcmpeqd, regs, regd)
-#define	pcmpeqw_m2r(var,reg)	mmx_m2r (pcmpeqw, var, reg)
-#define	pcmpeqw_r2r(regs,regd)	mmx_r2r (pcmpeqw, regs, regd)
-
-#define	pcmpgtb_m2r(var,reg)	mmx_m2r (pcmpgtb, var, reg)
-#define	pcmpgtb_r2r(regs,regd)	mmx_r2r (pcmpgtb, regs, regd)
-#define	pcmpgtd_m2r(var,reg)	mmx_m2r (pcmpgtd, var, reg)
-#define	pcmpgtd_r2r(regs,regd)	mmx_r2r (pcmpgtd, regs, regd)
-#define	pcmpgtw_m2r(var,reg)	mmx_m2r (pcmpgtw, var, reg)
-#define	pcmpgtw_r2r(regs,regd)	mmx_r2r (pcmpgtw, regs, regd)
-
-#define	pmaddwd_m2r(var,reg)	mmx_m2r (pmaddwd, var, reg)
-#define	pmaddwd_r2r(regs,regd)	mmx_r2r (pmaddwd, regs, regd)
-
-#define	pmulhw_m2r(var,reg)	mmx_m2r (pmulhw, var, reg)
-#define	pmulhw_r2r(regs,regd)	mmx_r2r (pmulhw, regs, regd)
-
-#define	pmullw_m2r(var,reg)	mmx_m2r (pmullw, var, reg)
-#define	pmullw_r2r(regs,regd)	mmx_r2r (pmullw, regs, regd)
-
-#define	por_m2r(var,reg)	mmx_m2r (por, var, reg)
-#define	por_r2r(regs,regd)	mmx_r2r (por, regs, regd)
-
-#define	pslld_i2r(imm,reg)	mmx_i2r (pslld, imm, reg)
-#define	pslld_m2r(var,reg)	mmx_m2r (pslld, var, reg)
-#define	pslld_r2r(regs,regd)	mmx_r2r (pslld, regs, regd)
-#define	psllq_i2r(imm,reg)	mmx_i2r (psllq, imm, reg)
-#define	psllq_m2r(var,reg)	mmx_m2r (psllq, var, reg)
-#define	psllq_r2r(regs,regd)	mmx_r2r (psllq, regs, regd)
-#define	psllw_i2r(imm,reg)	mmx_i2r (psllw, imm, reg)
-#define	psllw_m2r(var,reg)	mmx_m2r (psllw, var, reg)
-#define	psllw_r2r(regs,regd)	mmx_r2r (psllw, regs, regd)
-
-#define	psrad_i2r(imm,reg)	mmx_i2r (psrad, imm, reg)
-#define	psrad_m2r(var,reg)	mmx_m2r (psrad, var, reg)
-#define	psrad_r2r(regs,regd)	mmx_r2r (psrad, regs, regd)
-#define	psraw_i2r(imm,reg)	mmx_i2r (psraw, imm, reg)
-#define	psraw_m2r(var,reg)	mmx_m2r (psraw, var, reg)
-#define	psraw_r2r(regs,regd)	mmx_r2r (psraw, regs, regd)
-
-#define	psrld_i2r(imm,reg)	mmx_i2r (psrld, imm, reg)
-#define	psrld_m2r(var,reg)	mmx_m2r (psrld, var, reg)
-#define	psrld_r2r(regs,regd)	mmx_r2r (psrld, regs, regd)
-#define	psrlq_i2r(imm,reg)	mmx_i2r (psrlq, imm, reg)
-#define	psrlq_m2r(var,reg)	mmx_m2r (psrlq, var, reg)
-#define	psrlq_r2r(regs,regd)	mmx_r2r (psrlq, regs, regd)
-#define	psrlw_i2r(imm,reg)	mmx_i2r (psrlw, imm, reg)
-#define	psrlw_m2r(var,reg)	mmx_m2r (psrlw, var, reg)
-#define	psrlw_r2r(regs,regd)	mmx_r2r (psrlw, regs, regd)
-
-#define	psubb_m2r(var,reg)	mmx_m2r (psubb, var, reg)
-#define	psubb_r2r(regs,regd)	mmx_r2r (psubb, regs, regd)
-#define	psubd_m2r(var,reg)	mmx_m2r (psubd, var, reg)
-#define	psubd_r2r(regs,regd)	mmx_r2r (psubd, regs, regd)
-#define	psubw_m2r(var,reg)	mmx_m2r (psubw, var, reg)
-#define	psubw_r2r(regs,regd)	mmx_r2r (psubw, regs, regd)
-
-#define	psubsb_m2r(var,reg)	mmx_m2r (psubsb, var, reg)
-#define	psubsb_r2r(regs,regd)	mmx_r2r (psubsb, regs, regd)
-#define	psubsw_m2r(var,reg)	mmx_m2r (psubsw, var, reg)
-#define	psubsw_r2r(regs,regd)	mmx_r2r (psubsw, regs, regd)
-
-#define	psubusb_m2r(var,reg)	mmx_m2r (psubusb, var, reg)
-#define	psubusb_r2r(regs,regd)	mmx_r2r (psubusb, regs, regd)
-#define	psubusw_m2r(var,reg)	mmx_m2r (psubusw, var, reg)
-#define	psubusw_r2r(regs,regd)	mmx_r2r (psubusw, regs, regd)
-
-#define	punpckhbw_m2r(var,reg)		mmx_m2r (punpckhbw, var, reg)
-#define	punpckhbw_r2r(regs,regd)	mmx_r2r (punpckhbw, regs, regd)
-#define	punpckhdq_m2r(var,reg)		mmx_m2r (punpckhdq, var, reg)
-#define	punpckhdq_r2r(regs,regd)	mmx_r2r (punpckhdq, regs, regd)
-#define	punpckhwd_m2r(var,reg)		mmx_m2r (punpckhwd, var, reg)
-#define	punpckhwd_r2r(regs,regd)	mmx_r2r (punpckhwd, regs, regd)
-
-#define	punpcklbw_m2r(var,reg) 		mmx_m2r (punpcklbw, var, reg)
-#define	punpcklbw_r2r(regs,regd)	mmx_r2r (punpcklbw, regs, regd)
-#define	punpckldq_m2r(var,reg)		mmx_m2r (punpckldq, var, reg)
-#define	punpckldq_r2r(regs,regd)	mmx_r2r (punpckldq, regs, regd)
-#define	punpcklwd_m2r(var,reg)		mmx_m2r (punpcklwd, var, reg)
-#define	punpcklwd_r2r(regs,regd)	mmx_r2r (punpcklwd, regs, regd)
-
-#define	pxor_m2r(var,reg)	mmx_m2r (pxor, var, reg)
-#define	pxor_r2r(regs,regd)	mmx_r2r (pxor, regs, regd)
-
-
-/* 3DNOW extensions */
-
-#define pavgusb_m2r(var,reg)	mmx_m2r (pavgusb, var, reg)
-#define pavgusb_r2r(regs,regd)	mmx_r2r (pavgusb, regs, regd)
-
-
-/* AMD MMX extensions - also available in intel SSE */
-
-
-#define mmx_m2ri(op,mem,reg,imm) \
-        __asm__ __volatile__ (#op " %1, %0, %%" #reg \
-                              : /* nothing */ \
-                              : "X" (mem), "X" (imm))
-#define mmx_r2ri(op,regs,regd,imm) \
-        __asm__ __volatile__ (#op " %0, %%" #regs ", %%" #regd \
-                              : /* nothing */ \
-                              : "X" (imm) )
-
-#define	mmx_fetch(mem,hint) \
-	__asm__ __volatile__ ("prefetch" #hint " %0" \
-			      : /* nothing */ \
-			      : "X" (mem))
-
-
-#define	maskmovq(regs,maskreg)		mmx_r2ri (maskmovq, regs, maskreg)
-
-#define	movntq_r2m(mmreg,var)		mmx_r2m (movntq, mmreg, var)
-
-#define	pavgb_m2r(var,reg)		mmx_m2r (pavgb, var, reg)
-#define	pavgb_r2r(regs,regd)		mmx_r2r (pavgb, regs, regd)
-#define	pavgw_m2r(var,reg)		mmx_m2r (pavgw, var, reg)
-#define	pavgw_r2r(regs,regd)		mmx_r2r (pavgw, regs, regd)
-
-#define	pextrw_r2r(mmreg,reg,imm)	mmx_r2ri (pextrw, mmreg, reg, imm)
-
-#define	pinsrw_r2r(reg,mmreg,imm)	mmx_r2ri (pinsrw, reg, mmreg, imm)
-
-#define	pmaxsw_m2r(var,reg)		mmx_m2r (pmaxsw, var, reg)
-#define	pmaxsw_r2r(regs,regd)		mmx_r2r (pmaxsw, regs, regd)
-
-#define	pmaxub_m2r(var,reg)		mmx_m2r (pmaxub, var, reg)
-#define	pmaxub_r2r(regs,regd)		mmx_r2r (pmaxub, regs, regd)
-
-#define	pminsw_m2r(var,reg)		mmx_m2r (pminsw, var, reg)
-#define	pminsw_r2r(regs,regd)		mmx_r2r (pminsw, regs, regd)
-
-#define	pminub_m2r(var,reg)		mmx_m2r (pminub, var, reg)
-#define	pminub_r2r(regs,regd)		mmx_r2r (pminub, regs, regd)
-
-#define	pmovmskb(mmreg,reg) \
-	__asm__ __volatile__ ("movmskps %" #mmreg ", %" #reg)
-
-#define	pmulhuw_m2r(var,reg)		mmx_m2r (pmulhuw, var, reg)
-#define	pmulhuw_r2r(regs,regd)		mmx_r2r (pmulhuw, regs, regd)
-
-#define	prefetcht0(mem)			mmx_fetch (mem, t0)
-#define	prefetcht1(mem)			mmx_fetch (mem, t1)
-#define	prefetcht2(mem)			mmx_fetch (mem, t2)
-#define	prefetchnta(mem)		mmx_fetch (mem, nta)
-
-#define	psadbw_m2r(var,reg)		mmx_m2r (psadbw, var, reg)
-#define	psadbw_r2r(regs,regd)		mmx_r2r (psadbw, regs, regd)
-
-#define	pshufw_m2r(var,reg,imm)		mmx_m2ri(pshufw, var, reg, imm)
-#define	pshufw_r2r(regs,regd,imm)	mmx_r2ri(pshufw, regs, regd, imm)
-
-#define	sfence() __asm__ __volatile__ ("sfence\n\t")
-
-#endif /* AVCODEC_I386MMX_H */
+#include "xineutils.h"
--- libavcodec/libpostproc/postprocess.c	2003-11-01 18:43:19.000000000 +0100
+++ libavcodec/libpostproc/postprocess.c	2003-10-27 19:42:16.000000000 +0100
@@ -70,8 +70,9 @@
 #include "config.h"
 #include <inttypes.h>
 #include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
+
+#include "xineutils.h"
+
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
@@ -80,9 +81,9 @@
 //#undef HAVE_MMX
 //#undef ARCH_X86
 //#define DEBUG_BRIGHTNESS
-#ifdef USE_FASTMEMCPY
-#include "../fastmemcpy.h"
-#endif
+
+#define memcpy(a,b,c) xine_fast_memcpy(a,b,c)
+
 #include "postprocess.h"
 #include "postprocess_internal.h"
 
@@ -152,44 +153,6 @@
 	NULL //End Marker
 };
 
-#ifdef ARCH_X86
-static inline void unusedVariableWarningFixer()
-{
-	if(w05 + w20 + b00 + b01 + b02 + b08 + b80 == 0) b00=0;
-}
-#endif
-
-
-#ifdef ARCH_X86
-static inline void prefetchnta(void *p)
-{
-	asm volatile(	"prefetchnta (%0)\n\t"
-		: : "r" (p)
-	);
-}
-
-static inline void prefetcht0(void *p)
-{
-	asm volatile(	"prefetcht0 (%0)\n\t"
-		: : "r" (p)
-	);
-}
-
-static inline void prefetcht1(void *p)
-{
-	asm volatile(	"prefetcht1 (%0)\n\t"
-		: : "r" (p)
-	);
-}
-
-static inline void prefetcht2(void *p)
-{
-	asm volatile(	"prefetcht2 (%0)\n\t"
-		: : "r" (p)
-	);
-}
-#endif
-
 // The horizontal Functions exist only in C cuz the MMX code is faster with vertical filters and transposing
 
 /**
--- libavcodec/mjpeg.c	2003-11-01 18:43:19.000000000 +0100
+++ libavcodec/mjpeg.c	2003-10-27 19:42:08.000000000 +0100
@@ -1504,7 +1504,7 @@
 	    4bytes	field_size
 	    4bytes	field_size_less_padding
 	*/
-    	s->buggy_avid = 1;
+//    	s->buggy_avid = 1;
 //	if (s->first_picture)
 //	    printf("mjpeg: workarounding buggy AVID\n");
 	s->interlace_polarity = get_bits(&s->gb, 8);
--- libavcodec/mlib/dsputil_mlib.c	2003-11-01 18:43:19.000000000 +0100
+++ libavcodec/mlib/dsputil_mlib.c	2003-10-27 19:42:17.000000000 +0100
@@ -419,6 +419,7 @@
 
 void dsputil_init_mlib(DSPContext* c, AVCodecContext *avctx)
 {
+  if (xine_mm_accel() & MM_ACCEL_MLIB) {
     c->get_pixels  = get_pixels_mlib;
     c->diff_pixels = diff_pixels_mlib;
     c->add_pixels_clamped = add_pixels_clamped_mlib;
@@ -445,10 +446,12 @@
     c->put_no_rnd_pixels_tab[1][0] = put_pixels8_mlib;
 
     c->bswap_buf = bswap_buf_mlib;
+  }
 }
 
 void MPV_common_init_mlib(MpegEncContext *s)
 {
+  if (xine_mm_accel() & MM_ACCEL_MLIB) {
     if(s->avctx->dct_algo==FF_DCT_AUTO || s->avctx->dct_algo==FF_DCT_MLIB){
 	s->dsp.fdct = ff_fdct_mlib;
     }
@@ -459,4 +462,5 @@
         s->dsp.idct    = ff_idct_mlib;
         s->dsp.idct_permutation_type= FF_NO_IDCT_PERM;
     }
+  }
 }
--- libavcodec/mpeg12.c	2003-10-27 16:24:38.000000000 +0100
+++ libavcodec/mpeg12.c	2003-10-28 19:24:46.000000000 +0100
@@ -48,7 +48,7 @@
 #define MB_BTYPE_VLC_BITS 6
 #define TEX_VLC_BITS 9
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 static void mpeg1_encode_block(MpegEncContext *s, 
                          DCTELEM *block, 
                          int component);
@@ -74,7 +74,7 @@
 extern int XVMC_field_end(MpegEncContext *s);
 #endif
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 static uint8_t (*mv_penalty)[MAX_MV*2+1]= NULL;
 static uint8_t fcode_tab[MAX_MV*2+1];
 
@@ -128,7 +128,7 @@
     }
 }
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 static void init_uni_ac_vlc(RLTable *rl, uint32_t *uni_ac_vlc_bits, uint8_t *uni_ac_vlc_len){
     int i;
 
@@ -383,7 +383,7 @@
     memset(s->last_mv, 0, sizeof(s->last_mv));
 }
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 
 void ff_mpeg1_encode_slice_header(MpegEncContext *s){
     put_header(s, SLICE_MIN_START_CODE + s->mb_y);
--- libavcodec/mpegvideo.c	2003-11-01 18:43:19.000000000 +0100
+++ libavcodec/mpegvideo.c	2003-10-30 23:26:04.000000000 +0100
@@ -36,7 +36,7 @@
 //#undef NDEBUG
 //#include <assert.h>
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 static void encode_picture(MpegEncContext *s, int picture_number);
 #endif //CONFIG_ENCODERS
 static void dct_unquantize_mpeg1_c(MpegEncContext *s, 
@@ -46,7 +46,7 @@
 static void dct_unquantize_h263_c(MpegEncContext *s, 
                                   DCTELEM *block, int n, int qscale);
 static void draw_edges_c(uint8_t *buf, int wrap, int width, int height, int w);
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 static int dct_quantize_c(MpegEncContext *s, DCTELEM *block, int n, int qscale, int *overflow);
 static int dct_quantize_trellis_c(MpegEncContext *s, DCTELEM *block, int n, int qscale, int *overflow);
 static int sse_mb(MpegEncContext *s);
@@ -87,7 +87,7 @@
     0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2,
 };
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 static uint8_t (*default_mv_penalty)[MAX_MV*2+1]=NULL;
 static uint8_t default_fcode_tab[MAX_MV*2+1];
 
@@ -173,7 +173,7 @@
     }
 }
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 void ff_write_quant_matrix(PutBitContext *pb, int16_t *matrix){
     int i;
 
@@ -194,7 +194,7 @@
     s->dct_unquantize_mpeg1 = dct_unquantize_mpeg1_c;
     s->dct_unquantize_mpeg2 = dct_unquantize_mpeg2_c;
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
     s->dct_quantize= dct_quantize_c;
 #endif
         
@@ -217,7 +217,7 @@
     MPV_common_init_ppc(s);
 #endif
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
     s->fast_dct_quantize= s->dct_quantize;
 
     if(s->flags&CODEC_FLAG_TRELLIS_QUANT){
@@ -569,7 +569,7 @@
     s->current_picture_ptr= NULL;
 }
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 
 /* init video encoder */
 int MPV_encode_init(AVCodecContext *avctx)
@@ -686,6 +686,7 @@
         s->low_delay= 0; //s->max_b_frames ? 0 : 1;
         avctx->delay= s->low_delay ? 0 : (s->max_b_frames + 1);
         break;
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
     case CODEC_ID_MPEG2VIDEO:
         s->out_format = FMT_MPEG1;
         s->low_delay= 0; //s->max_b_frames ? 0 : 1;
@@ -802,6 +803,7 @@
         s->low_delay=1;
         break;
 #endif
+#endif
     default:
         return -1;
     }
@@ -836,22 +838,25 @@
     if (MPV_common_init(s) < 0)
         return -1;
     
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
     ff_init_me(s);
+#endif
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
 #ifdef CONFIG_RISKY
     if (s->out_format == FMT_H263)
         h263_encode_init(s);
     if(s->msmpeg4_version)
         ff_msmpeg4_encode_init(s);
 #endif
+#endif
     if (s->out_format == FMT_MPEG1)
         ff_mpeg1_encode_init(s);
-#endif
 
     /* init default q matrix */
     for(i=0;i<64;i++) {
         int j= s->dsp.idct_permutation[i];
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
 #ifdef CONFIG_RISKY
         if(s->codec_id==CODEC_ID_MPEG4 && s->mpeg_quant){
             s->intra_matrix[j] = ff_mpeg4_default_intra_matrix[i];
@@ -861,6 +866,7 @@
             s->inter_matrix[j] = ff_mpeg1_default_non_intra_matrix[i];
         }else
 #endif
+#endif
         { /* mpeg1/2 */
             s->intra_matrix[j] = ff_mpeg1_default_intra_matrix[i];
             s->inter_matrix[j] = ff_mpeg1_default_non_intra_matrix[i];
@@ -904,8 +910,10 @@
     ff_rate_control_uninit(s);
 
     MPV_common_end(s);
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
     if (s->out_format == FMT_MJPEG)
         mjpeg_close(s);
+#endif
 
     av_freep(&avctx->extradata);
       
@@ -1341,7 +1349,7 @@
     }
 }
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 
 static int get_sae(uint8_t *src, int ref, int stride){
     int x,y;
@@ -1634,11 +1642,13 @@
 
         MPV_frame_end(s);
 
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
         if (s->out_format == FMT_MJPEG)
             mjpeg_picture_trailer(s);
         
         if(s->flags&CODEC_FLAG_PASS1)
             ff_write_pass1_stats(s);
+#endif
 
         for(i=0; i<4; i++){
             avctx->error[i] += s->current_picture_ptr->error[i];
@@ -2607,7 +2617,7 @@
     }
 }
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 
 static inline void dct_single_coeff_elimination(MpegEncContext *s, int n, int threshold)
 {
@@ -2812,7 +2822,7 @@
     }    
 }
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 
 static void encode_mb(MpegEncContext *s, int motion_x, int motion_y)
 {
@@ -3051,6 +3061,7 @@
     case CODEC_ID_MPEG1VIDEO:
     case CODEC_ID_MPEG2VIDEO:
         mpeg1_encode_mb(s, s->block, motion_x, motion_y); break;
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
 #ifdef CONFIG_RISKY
     case CODEC_ID_MPEG4:
         mpeg4_encode_mb(s, s->block, motion_x, motion_y); break;
@@ -3068,6 +3079,7 @@
 #endif
     case CODEC_ID_MJPEG:
         mjpeg_encode_mb(s, s->block); break;
+#endif
     default:
         assert(0);
     }
@@ -3152,7 +3164,7 @@
     s->parse_context.last_index= 0;
 }
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 void ff_copy_bits(PutBitContext *pb, uint8_t *src, int length)
 {
     int bytes= length>>4;
@@ -3340,12 +3352,14 @@
     s->current_picture.mb_var_sum = 0;
     s->current_picture.mc_mb_var_sum = 0;
 
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
 #ifdef CONFIG_RISKY
     /* we need to initialize some time vars before we can encode b-frames */
     // RAL: Condition added for MPEG1VIDEO
     if (s->codec_id == CODEC_ID_MPEG1VIDEO || s->codec_id == CODEC_ID_MPEG2VIDEO || (s->h263_pred && !s->h263_msmpeg4))
         ff_set_mpeg4_time(s, s->picture_number); 
 #endif
+#endif
         
     s->scene_change_score=0;
     
@@ -3362,6 +3376,7 @@
     /* Estimate motion for every MB */
     s->mb_intra=0; //for the rate distoration & bit compare functions
     if(s->pict_type != I_TYPE){
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
         if(s->pict_type != B_TYPE){
             if((s->avctx->pre_me && s->last_non_b_pict_type==I_TYPE) || s->avctx->pre_me==2){
                 s->me.pre_pass=1;
@@ -3399,6 +3414,7 @@
                     ff_estimate_p_frame_motion(s, mb_x, mb_y);
             }
         }
+#endif
     }else /* if(s->pict_type == I_TYPE) */{
         /* I-Frame */
         //FIXME do we need to zero them?
@@ -3433,6 +3449,7 @@
 //printf("Scene change detected, encoding as I Frame %d %d\n", s->current_picture.mb_var_sum, s->current_picture.mc_mb_var_sum);
     }
 
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
     if(!s->umvplus){
         if(s->pict_type==P_TYPE || s->pict_type==S_TYPE) {
             s->f_code= ff_get_best_fcode(s, s->p_mv_table, MB_TYPE_INTER);
@@ -3457,11 +3474,13 @@
             ff_fix_long_b_mvs(s, s->b_bidir_back_mv_table, s->b_code, MB_TYPE_BIDIR);
         }
     }
+#endif
     
     if (!s->fixed_qscale) 
         s->current_picture.quality = ff_rate_estimate_qscale(s);
 
     if(s->adaptive_quant){
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
 #ifdef CONFIG_RISKY
         switch(s->codec_id){
         case CODEC_ID_MPEG4:
@@ -3474,6 +3493,7 @@
             break;
         }
 #endif
+#endif
 
         s->lambda= s->lambda_table[0];
         //FIXME broken
@@ -3506,6 +3526,7 @@
 
     s->last_bits= get_bit_count(&s->pb);
     switch(s->out_format) {
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
     case FMT_MJPEG:
         mjpeg_picture_header(s);
         break;
@@ -3524,6 +3545,15 @@
         else
             h263_encode_picture_header(s, picture_number);
         break;
+#else
+    case FMT_H263:
+        break;
+#endif
+#else
+    case FMT_MJPEG:
+        break;
+    case FMT_H263:
+        break;
 #endif
     case FMT_MPEG1:
         mpeg1_encode_picture_header(s, picture_number);
@@ -3558,6 +3588,7 @@
      
     s->last_mv_dir = 0;
 
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
 #ifdef CONFIG_RISKY
     switch(s->codec_id){
     case CODEC_ID_H263:
@@ -3571,6 +3602,7 @@
         break;
     }
 #endif
+#endif
 
     s->resync_mb_x=0;
     s->resync_mb_y=0;
@@ -3594,6 +3626,7 @@
             ff_update_block_index(s);
 
             /* write gob / video packet header  */
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
 #ifdef CONFIG_RISKY
             if(s->rtp_mode && mb_y + mb_x>0){
                 int current_packet_size, is_gob_start;
@@ -3649,6 +3682,7 @@
                 }
             }
 #endif
+#endif
 
             if(  (s->resync_mb_x   == s->mb_x)
                && s->resync_mb_y+1 == s->mb_y){
@@ -3734,9 +3768,11 @@
                     
                     s->mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD | MV_DIRECT;
                     s->mb_intra= 0;
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
 #ifdef CONFIG_RISKY
                     ff_mpeg4_set_direct_mv(s, mx, my);
 #endif
+#endif
                     encode_mb_hq(s, &backup_s, &best_s, MB_TYPE_DIRECT, pb, pb2, tex_pb, 
                                  &dmin, &next_block, mx, my);
                 }
@@ -3905,9 +3941,11 @@
                     s->mb_intra= 0;
                     motion_x=s->b_direct_mv_table[xy][0];
                     motion_y=s->b_direct_mv_table[xy][1];
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
 #ifdef CONFIG_RISKY
                     ff_mpeg4_set_direct_mv(s, motion_x, motion_y);
 #endif
+#endif
                     break;
                 case MB_TYPE_BIDIR:
                     s->mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD;
@@ -3978,6 +4016,7 @@
     }
     emms_c();
 
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
 #ifdef CONFIG_RISKY
     if(s->codec_id==CODEC_ID_MPEG4 && s->partitioned_frame)
         ff_mpeg4_merge_partitions(s);
@@ -3988,6 +4027,7 @@
     if(s->codec_id==CODEC_ID_MPEG4) 
         ff_mpeg4_stuffing(&s->pb);
 #endif
+#endif
 
     //if (s->gob_number)
     //    fprintf(stderr,"\nNumber of GOB: %d", s->gob_number);
@@ -4626,7 +4666,7 @@
     AVOPTION_END()
 };
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_ENCODERS) || defined(XINE_MPEG_ENCODER)
 
 AVCodec mpeg1video_encoder = {
     "mpeg1video",
@@ -4638,6 +4678,7 @@
     MPV_encode_end,
 };
 
+#if defined(CONFIG_ENCODERS) || !defined(XINE_MPEG_ENCODER)
 #ifdef CONFIG_RISKY
 
 AVCodec mpeg2video_encoder = {
@@ -4757,5 +4798,7 @@
     MPV_encode_end,
 };
 
+#endif
+
 #endif //CONFIG_ENCODERS
 
--- libavcodec/msvideo1.c	2003-10-27 16:24:38.000000000 +0100
+++ libavcodec/msvideo1.c	2003-10-28 21:04:59.000000000 +0100
@@ -38,6 +38,8 @@
 #include "avcodec.h"
 #include "dsputil.h"
 
+#undef LE_16
+
 #define PALETTE_COUNT 256
 #define LE_16(x)  ((((uint8_t*)(x))[1] << 8) | ((uint8_t*)(x))[0])
 #define CHECK_STREAM_PTR(n) \
--- libavcodec/rpza.c	2003-10-27 16:24:38.000000000 +0100
+++ libavcodec/rpza.c	2003-10-28 21:05:35.000000000 +0100
@@ -54,6 +54,9 @@
 
 } RpzaContext;
 
+#undef BE_16
+#undef BE_32
+
 #define BE_16(x)  ((((uint8_t*)(x))[0] << 8) | ((uint8_t*)(x))[1])
 #define BE_32(x)  ((((uint8_t*)(x))[0] << 24) | \
                    (((uint8_t*)(x))[1] << 16) | \
--- libavcodec/vqavideo.c	2003-10-30 07:00:28.000000000 +0100
+++ libavcodec/vqavideo.c	2003-10-30 20:13:31.000000000 +0100
@@ -82,6 +82,10 @@
 #define MAX_VECTORS (MAX_CODEBOOK_VECTORS + SOLID_PIXEL_VECTORS)
 #define MAX_CODEBOOK_SIZE (MAX_VECTORS * 4 * 4)
 
+#undef LE_16
+#undef BE_16
+#undef BE_32
+
 #define LE_16(x)  ((((uint8_t*)(x))[1] << 8) | ((uint8_t*)(x))[0])
 #define BE_16(x)  ((((uint8_t*)(x))[0] << 8) | ((uint8_t*)(x))[1])
 #define BE_32(x)  ((((uint8_t*)(x))[0] << 24) | \
--- libavcodec/xan.c	2003-10-30 07:00:29.000000000 +0100
+++ libavcodec/xan.c	2003-10-30 23:27:28.000000000 +0100
@@ -58,6 +58,10 @@
 
 } XanContext;
 
+#undef BE_16
+#undef LE_16
+#undef LE_32
+
 #define BE_16(x)  ((((uint8_t*)(x))[0] << 8) | ((uint8_t*)(x))[1])
 #define LE_16(x)  ((((uint8_t*)(x))[1] << 8) | ((uint8_t*)(x))[0])
 #define LE_32(x)  ((((uint8_t*)(x))[3] << 24) | \
@@ -69,6 +73,8 @@
 #define SCALEFACTOR 65536
 #define CENTERSAMPLE 128
 
+#undef COMPUTE_Y
+
 #define COMPUTE_Y(r, g, b) \
   (unsigned char) \
   ((y_r_table[r] + y_g_table[g] + y_b_table[b]) / SCALEFACTOR)
